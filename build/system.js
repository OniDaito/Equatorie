// Generated by CoffeeScript 1.6.3
(function() {
  var EquatorieSystem;

  EquatorieSystem = (function() {
    function EquatorieSystem() {
      this.base_radius = 6.0;
      this.epicycle_radius = 6.0;
      this.epicycle_thickness = 0.333334;
      this.precession = 0.00003838;
      this.planet_data = {};
      this.planet_data.venus = {
        deferent_speed: 0.98564734,
        epicycle_speed: 0.61652156,
        epicycle_ratio: 0.72294,
        deferent_eccentricity: 0.0145,
        apogee_longitude: 98.1666667,
        mean_longitude: 279.7,
        mean_anomaly: 63.383
      };
      this.planet_data.mars = {
        deferent_speed: 0.52407116,
        epicycle_speed: 0.46157618,
        epicycle_ratio: 0.6563,
        deferent_eccentricity: 0.10284,
        apogee_longitude: 148.6166667,
        mean_longitude: 293.55,
        mean_anomaly: 346.15
      };
      this.planet_data.jupiter = {
        deferent_speed: 0.08312944,
        epicycle_speed: 0.90251790,
        epicycle_ratio: 0.1922,
        deferent_eccentricity: 0.04817,
        apogee_longitude: 188.9666667,
        mean_longitude: 238.16666667,
        mean_anomaly: 41.5333333
      };
      this.planet_data.saturn = {
        deferent_speed: 0.03349795,
        epicycle_speed: 0.95214939,
        epicycle_ratio: 0.10483,
        deferent_eccentricity: 0.05318,
        apogee_longitude: 270.76666667,
        mean_longitude: 266.25,
        mean_anomaly: 13.45
      };
      this.epoch = new Date("January 1, 1900 00:00:00");
      this.epoch_julian = 2415020;
      this.reset();
    }

    EquatorieSystem.prototype.solveForPlanetDate = function(planet, date) {
      this._setPlanet(planet);
      this._calculateDate(date);
      this._calculateDeferentAngle();
      this._calculateDeferentPosition();
      this._calculateEquantPosition();
      this._calculateMeanMotus();
      this._calculateParallel();
      this._calculateEpicyclePosition();
      this._calculatePointerAngle();
      this._calculatePointerPoint();
      return this._calculateTruePlace();
    };

    EquatorieSystem.prototype.reset = function() {
      return this.state = {
        meanMotus: 0,
        meanMotusPosition: 0,
        deferentAngle: 0,
        deferentPosition: 0,
        passed: 0,
        planet: '',
        date: 0,
        parallelPosition: 0,
        pointerAngle: 0,
        equantPosition: 0,
        epicycleRotation: 0,
        epicyclePosition: 0,
        epicyclePrePosition: 0,
        basePosition: 0,
        truePlace: 0
      };
    };

    EquatorieSystem.prototype._setPlanet = function(planet) {
      this.state.planet = planet;
      return this;
    };

    EquatorieSystem.prototype._calculateDate = function(date) {
      var a, j, m, p, y;
      a = (14 - (date.getMonth() + 1)) / 12;
      y = date.getFullYear() + 4800 - a;
      m = (date.getMonth() + 1) + (12 * a) - 3;
      j = date.getDate() + (153 * m + 2) / 5 + (365 * y) + (y / 4) - (y / 100) + (y / 400) - 32045;
      p = j - this.epoch_julian;
      this.state.passed = p;
      return p;
    };

    EquatorieSystem.prototype._calculateDeferentAngle = function() {
      var angle, _ref;
      if ((_ref = this.state.planet) === 'mars' || _ref === 'venus' || _ref === 'jupiter' || _ref === 'saturn') {
        angle = -this.planet_data[this.state.planet].apogee_longitude - (this.precession * this.state.date);
        this.state.deferentAngle = angle;
        return angle;
      }
      return this;
    };

    EquatorieSystem.prototype._calculateDeferentPosition = function() {
      var x, y, _ref;
      if ((_ref = this.state.planet) === 'mars' || _ref === 'venus' || _ref === 'jupiter' || _ref === 'saturn') {
        x = this.base_radius * this.planet_data[this.state.planet].deferent_eccentricity * Math.cos(CoffeeGL.degToRad(this.state.deferentAngle));
        y = this.base_radius * this.planet_data[this.state.planet].deferent_eccentricity * Math.sin(CoffeeGL.degToRad(this.state.deferentAngle));
        this.state.deferentPosition = new CoffeeGL.Vec2(x, y);
        return this.state.deferentPosition;
      }
      return this;
    };

    EquatorieSystem.prototype._calculateEquantPosition = function() {
      var _ref;
      if ((_ref = this.state.planet) === 'mars' || _ref === 'venus' || _ref === 'jupiter' || _ref === 'saturn') {
        this.state.equantPosition = new CoffeeGL.Vec2(this.state.deferentPosition.x * 2, this.state.deferentPosition.y * 2);
        return this.state.equantPosition;
      }
    };

    EquatorieSystem.prototype._calculateMeanMotus = function() {
      var mean_motus_angle, mean_motus_position, passed;
      passed = this.state.passed;
      mean_motus_angle = (this.planet_data[this.state.planet].mean_longitude + (this.planet_data[this.state.planet].deferent_speed * passed)) % 360 * -1;
      this.state.meanMotus = mean_motus_angle;
      mean_motus_position = new CoffeeGL.Vec2(this.base_radius * Math.cos(CoffeeGL.degToRad(mean_motus_angle)), this.base_radius * Math.sin(CoffeeGL.degToRad(mean_motus_angle)));
      this.state.meanMotusPosition = mean_motus_position;
      return [mean_motus_angle, mean_motus_position];
    };

    EquatorieSystem.prototype.rayCircleIntersection = function(ray_start, ray_dir, circle_centre, circle_radius) {
      var a, b, c, d2, discriminant, f, r, t, t1, t2, v;
      f = CoffeeGL.Vec2.sub(ray_start, circle_centre);
      r = circle_radius;
      a = ray_dir.dot(ray_dir);
      b = 2 * f.dot(ray_dir);
      c = f.dot(f) - r * r;
      v = new CoffeeGL.Vec2();
      discriminant = b * b - 4 * a * c;
      if (discriminant !== 0) {
        discriminant = Math.sqrt(discriminant);
        t1 = (-b - discriminant) / (2 * a);
        t2 = (-b + discriminant) / (2 * a);
        t = t2;
        if (t2 < 0) {
          t = t1;
        }
        v.copyFrom(ray_start);
        d2 = CoffeeGL.Vec2.multScalar(ray_dir, t);
        v.add(d2);
      }
      return v;
    };

    EquatorieSystem.prototype._calculateParallel = function() {
      var base_position, cr, dangle, deferent_position, dir, equant_position, passed, sr;
      passed = this.state.passed;
      dangle = this.state.deferentAngle;
      cr = Math.cos(CoffeeGL.degToRad(dangle));
      sr = Math.sin(CoffeeGL.degToRad(dangle));
      base_position = new CoffeeGL.Vec2(this.base_radius * cr, this.base_radius * sr);
      this.state.basePosition = base_position;
      deferent_position = this.state.deferentPosition;
      equant_position = this.state.equantPosition;
      dir = this.state.meanMotusPosition.copy();
      dir.normalize();
      this.state.parallelPosition = this.rayCircleIntersection(equant_position, dir, deferent_position, this.base_radius);
      return this.state.parallelPosition;
    };

    EquatorieSystem.prototype._calculateEpicyclePosition = function() {
      var dangle, deferent_position, equant_position, f0, f1, fangle, l, passed, v;
      passed = this.state.passed;
      dangle = this.state.deferentAngle;
      deferent_position = this.state.deferentPosition;
      equant_position = this.state.equantPosition;
      l = deferent_position.length() + this.epicycle_radius - this.epicycle_thickness;
      this.state.epicyclePrePosition = CoffeeGL.Vec2.normalize(deferent_position).multScalar(l);
      fangle = 0;
      v = this.state.parallelPosition;
      if (v.x !== 0 && v.y !== 0) {
        f0 = CoffeeGL.radToDeg(Math.atan2(this.state.basePosition.y - deferent_position.y, this.state.basePosition.x - deferent_position.x));
        f1 = CoffeeGL.radToDeg(Math.atan2(v.y - deferent_position.y, v.x - deferent_position.x));
        fangle = f0 - f1;
      }
      this.state.epicycleRotation = fangle;
      return [deferent_position, this.state.basePosition, v, dangle, fangle];
    };

    EquatorieSystem.prototype._calculatePointerAngle = function() {
      var aa, angle, ca, dv, epipos, pa, passed, pt0, pt1, sa;
      passed = this.state.passed;
      angle = this.planet_data[this.state.planet].mean_anomaly + (this.planet_data[this.state.planet].epicycle_speed * passed);
      ca = Math.cos(CoffeeGL.degToRad(-this.state.epicycleRotation));
      sa = Math.sin(CoffeeGL.degToRad(-this.state.epicycleRotation));
      epipos = new CoffeeGL.Vec2(this.state.basePosition.x * ca - this.state.basePosition.y * sa, this.state.basePosition.x * sa + this.state.basePosition.y * ca);
      epipos.add(this.state.deferentPosition);
      this.state.epicyclePosition = epipos;
      pt0 = CoffeeGL.Vec2.sub(this.state.meanMotusPosition, this.state.deferentPosition);
      pt1 = CoffeeGL.Vec2.sub(epipos, this.state.deferentPosition);
      aa = CoffeeGL.radToDeg(Math.acos(CoffeeGL.Vec2.dot(CoffeeGL.Vec2.normalize(pt0), CoffeeGL.Vec2.normalize(pt1))));
      dv = CoffeeGL.Vec3.cross(new CoffeeGL.Vec3(0, 1, 0), new CoffeeGL.Vec3(pt0.x, 0, pt0.y));
      if (dv.x > 0) {
        aa *= -1;
      }
      pa = 90 - (aa / 2) + angle;
      this.state.pointerAngle = pa;
      return pa;
    };

    EquatorieSystem.prototype._calculatePointerPoint = function() {
      var angle, ca, deferent_position, dir, epipos, equant_position, fangle, motus_angle, motus_position, perp, sa;
      angle = this.state.pointerAngle;
      deferent_position = this.state.deferentPosition;
      motus_angle = this.state.meanMotus;
      motus_position = this.state.meanMotusPosition;
      equant_position = this.state.equantPosition;
      dir = motus_position.copy();
      dir.normalize();
      fangle = this.state.epicycleRotation;
      ca = Math.cos(CoffeeGL.degToRad(-fangle));
      sa = Math.sin(CoffeeGL.degToRad(-fangle));
      epipos = this.state.epicyclePosition;
      dir = CoffeeGL.Vec2.normalize(CoffeeGL.Vec2.sub(epipos, deferent_position));
      perp = dir.copy();
      perp.x = -dir.y;
      perp.y = dir.x;
      perp.multScalar(this.base_radius * this.planet_data[this.state.planet].epicycle_ratio);
      ca = Math.cos(CoffeeGL.degToRad(-angle));
      sa = Math.sin(CoffeeGL.degToRad(-angle));
      perp = new CoffeeGL.Vec2(perp.x * ca - perp.y * sa, perp.x * sa + perp.y * ca);
      perp.add(epipos);
      this.state.pointerPoint = perp;
      return perp;
    };

    EquatorieSystem.prototype._calculateTruePlace = function() {
      var angle, dir, pp, xaxis;
      pp = this.state.pointerPoint;
      dir = CoffeeGL.Vec2.normalize(pp);
      xaxis = new CoffeeGL.Vec2(1, 0);
      angle = CoffeeGL.radToDeg(Math.acos(xaxis.dot(dir)));
      this.state.truePlace = angle;
      return angle;
    };

    return EquatorieSystem;

  })();

  module.exports = {
    EquatorieSystem: EquatorieSystem
  };

}).call(this);
