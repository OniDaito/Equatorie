// Generated by CoffeeScript 1.6.3
(function() {
  var EquatorieSystem;

  EquatorieSystem = (function() {
    function EquatorieSystem() {
      this.base_radius = 6.0;
      this.epicycle_radius = 6.353;
      this.epicycle_thickness = this.epicycle_radius - this.base_radius;
      this.precession = 0.00003838;
      this.planet_data = {};
      this.planet_data.venus = {
        deferent_speed: 0.985,
        epicycle_speed: 0.616,
        epicycle_ratio: 0.72294,
        deferent_eccentricity: 0.0145,
        apogee_longitude: 98.1666667,
        mean_longitude: 279.7,
        mean_anomaly: 63.383
      };
      this.planet_data.mars = {
        deferent_speed: 0.524,
        epicycle_speed: 0.461,
        epicycle_ratio: 0.6563,
        deferent_eccentricity: 0.10284,
        apogee_longitude: 148.6166667,
        mean_longitude: 293.55,
        mean_anomaly: 346.15
      };
      this.planet_data.jupiter = {
        deferent_speed: 0.083,
        epicycle_speed: 0.902,
        epicycle_ratio: 0.1922,
        deferent_eccentricity: 0.04817,
        apogee_longitude: 188.9666667,
        mean_longitude: 238.16666667,
        mean_anomaly: 41.5333333
      };
      this.planet_data.saturn = {
        deferent_speed: 0.033,
        epicycle_speed: 0.952,
        epicycle_ratio: 0.10483,
        deferent_eccentricity: 0.05318,
        apogee_longitude: 148.6166667,
        mean_longitude: 266.25,
        mean_anomaly: 13.45
      };
      this.mean_motus_angle = 0;
    }

    EquatorieSystem.prototype.calculateDeferentAngle = function(planet, date) {
      var angle;
      angle = 360 - this.planet_data[planet].apogee_longitude - (this.precession * this.calculateDate(date));
      return angle;
    };

    EquatorieSystem.prototype.calculateDeferentPosition = function(planet, date) {
      var x, y;
      x = this.base_radius * this.planet_data[planet].deferent_eccentricity * Math.cos(CoffeeGL.degToRad(this.calculateDeferentAngle(planet, date)));
      y = this.base_radius * this.planet_data[planet].deferent_eccentricity * Math.sin(CoffeeGL.degToRad(this.calculateDeferentAngle(planet, date)));
      return [x, y];
    };

    EquatorieSystem.prototype.calculateEquantPosition = function(planet, date) {
      var x, y, _ref;
      _ref = this.calculateDeferentPosition(planet, date), x = _ref[0], y = _ref[1];
      return new CoffeeGL.Vec2(x * 2, y * 2);
    };

    EquatorieSystem.prototype.calculateDate = function(date) {
      var epoch, passed;
      epoch = new Date("January 1, 1900 00:00:00");
      passed = Math.abs(date - epoch) / 86400000;
      return passed;
    };

    EquatorieSystem.prototype.calculateMeanMotus = function(planet, date) {
      var passed;
      passed = this.calculateDate(date);
      this.mean_motus_angle = 360 - (this.planet_data[planet].mean_longitude + this.planet_data[planet].deferent_speed * passed % 360);
      return new CoffeeGL.Vec2(this.base_radius * Math.cos(CoffeeGL.degToRad(this.mean_motus_angle)), this.base_radius * Math.sin(CoffeeGL.degToRad(this.mean_motus_angle)));
    };

    EquatorieSystem.prototype.rayCircleIntersection = function(ray_start, ray_dir, circle_centre, circle_radius) {
      var a, b, c, d2, discriminant, f, r, t, t1, t2, v;
      f = CoffeeGL.Vec2.sub(ray_start, circle_centre);
      r = circle_radius;
      a = ray_dir.dot(ray_dir);
      b = 2 * f.dot(ray_dir);
      c = f.dot(f) - r * r;
      v = new CoffeeGL.Vec2();
      discriminant = b * b - 4 * a * c;
      if (discriminant !== 0) {
        discriminant = Math.sqrt(discriminant);
        t1 = (-b - discriminant) / (2 * a);
        t2 = (-b + discriminant) / (2 * a);
        t = t2;
        if (t2 < 0) {
          t = t1;
        }
        v.copyFrom(ray_start);
        d2 = CoffeeGL.Vec2.multScalar(ray_dir, t);
        v.add(d2);
      }
      return v;
    };

    EquatorieSystem.prototype.calculateParallel = function(planet, date) {
      var base_position, cr, dangle, deferent_position, dir, equant_position, motus_position, passed, sr;
      passed = this.calculateDate(date);
      dangle = this.calculateDeferentAngle(planet, date);
      cr = Math.cos(CoffeeGL.degToRad(dangle));
      sr = Math.sin(CoffeeGL.degToRad(dangle));
      base_position = new CoffeeGL.Vec2(this.base_radius * cr, this.base_radius * sr);
      deferent_position = new CoffeeGL.Vec2(base_position.x * this.planet_data[planet].deferent_eccentricity, base_position.y * this.planet_data[planet].deferent_eccentricity);
      equant_position = this.calculateEquantPosition(planet, date);
      motus_position = this.calculateMeanMotus(planet, date);
      dir = motus_position.copy();
      dir.normalize();
      return this.rayCircleIntersection(equant_position, dir, deferent_position, this.base_radius);
    };

    EquatorieSystem.prototype.calculateEpicyclePosition = function(planet, date) {
      var base_position, cr, dangle, deferent_position, equant_position, f0, f1, fangle, passed, sr, v;
      passed = this.calculateDate(date);
      dangle = this.calculateDeferentAngle(planet, date);
      cr = Math.cos(CoffeeGL.degToRad(dangle));
      sr = Math.sin(CoffeeGL.degToRad(dangle));
      base_position = new CoffeeGL.Vec2(this.base_radius * cr, this.base_radius * sr);
      deferent_position = new CoffeeGL.Vec2(base_position.x * this.planet_data[planet].deferent_eccentricity, base_position.y * this.planet_data[planet].deferent_eccentricity);
      equant_position = this.calculateEquantPosition(planet, date);
      fangle = 0;
      v = this.calculateParallel(planet, date);
      if (v.x !== 0 && v.y !== 0) {
        f0 = CoffeeGL.radToDeg(Math.atan2(base_position.y - deferent_position.y, base_position.x - deferent_position.x));
        f1 = CoffeeGL.radToDeg(Math.atan2(v.y - deferent_position.y, v.x - deferent_position.x));
        fangle = f0 - f1;
      }
      return [deferent_position, base_position, v, dangle, fangle];
    };

    EquatorieSystem.prototype.calculatePointerAngle = function(planet, date) {
      var aa, angle, base_position, ca, dangle, deferent_position, dv, epipos, fangle, mm, passed, pt0, pt1, sa, v, _ref;
      passed = this.calculateDate(date);
      angle = (this.planet_data[planet].mean_anomaly + (this.planet_data[planet].epicycle_speed * passed)) % 360;
      mm = this.calculateMeanMotus(planet, date);
      _ref = this.calculateEpicyclePosition(planet, date), deferent_position = _ref[0], base_position = _ref[1], v = _ref[2], dangle = _ref[3], fangle = _ref[4];
      ca = Math.cos(CoffeeGL.degToRad(-fangle));
      sa = Math.sin(CoffeeGL.degToRad(-fangle));
      epipos = new CoffeeGL.Vec2(base_position.x * ca - base_position.y * sa, base_position.x * sa + base_position.y * ca);
      epipos.add(deferent_position);
      pt0 = CoffeeGL.Vec2.sub(mm, deferent_position);
      pt1 = CoffeeGL.Vec2.sub(epipos, deferent_position);
      aa = CoffeeGL.radToDeg(Math.acos(CoffeeGL.Vec2.dot(CoffeeGL.Vec2.normalize(pt0), CoffeeGL.Vec2.normalize(pt1))));
      dv = CoffeeGL.Vec3.cross(new CoffeeGL.Vec3(0, 1, 0), new CoffeeGL.Vec3(pt0.x, 0, pt0.y));
      if (dv.x > 0) {
        aa *= -1;
      }
      return 90 - (aa / 2) - angle;
    };

    EquatorieSystem.prototype.calculatePointerPoint = function(planet, date) {
      var angle, base_position, ca, dangle, deferent_position, dir, epipos, equant_position, fangle, motus_position, perp, sa, v, _ref;
      angle = this.calculatePointerAngle(planet, date);
      deferent_position = this.calculateDeferentPosition(planet, date);
      motus_position = this.calculateMeanMotus(planet, date);
      equant_position = this.calculateEquantPosition(planet, date);
      dir = motus_position.copy();
      dir.normalize();
      _ref = this.calculateEpicyclePosition(planet, date), deferent_position = _ref[0], base_position = _ref[1], v = _ref[2], dangle = _ref[3], fangle = _ref[4];
      ca = Math.cos(CoffeeGL.degToRad(-fangle));
      sa = Math.sin(CoffeeGL.degToRad(-fangle));
      epipos = new CoffeeGL.Vec2(base_position.x * ca - base_position.y * sa, base_position.x * sa + base_position.y * ca);
      epipos.add(deferent_position);
      dir = CoffeeGL.Vec2.normalize(CoffeeGL.Vec2.sub(epipos, deferent_position));
      perp = dir.copy();
      perp.x = dir.y;
      perp.y = -dir.x;
      perp.multScalar(this.base_radius * this.planet_data[planet].epicycle_ratio);
      ca = Math.cos(CoffeeGL.degToRad(-angle));
      sa = Math.sin(CoffeeGL.degToRad(-angle));
      perp = new CoffeeGL.Vec2(perp.x * ca - perp.y * sa, perp.x * sa + perp.y * ca);
      return perp.add(epipos);
    };

    EquatorieSystem.prototype.calculateTruePlace = function(planet, date) {
      var angle, dir, pp, xaxis;
      pp = this.calculatePointerPoint(planet, date);
      dir = CoffeeGL.Vec2.normalize(pp);
      xaxis = new CoffeeGL.Vec2(1, 0);
      return angle = CoffeeGL.radToDeg(Math.acos(xaxis.dot(dir)));
    };

    return EquatorieSystem;

  })();

  module.exports = {
    EquatorieSystem: EquatorieSystem
  };

}).call(this);
