// Generated by CoffeeScript 1.6.3
(function() {
  var EquatorieString,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EquatorieString = (function(_super) {
    __extends(EquatorieString, _super);

    function EquatorieString(length, thickness, segments) {
      var seglength;
      EquatorieString.__super__.constructor.call(this);
      seglength = length / segments;
      this.add(this._makeSegments(thickness, 12, seglength, segments));
    }

    EquatorieString.prototype._makeSegments = function(radius, resolution, height, segments) {
      var e, geom, i, j, s, tangent, x, z, _i, _j, _k, _l, _m, _n, _o, _p, _ref, _ref1, _ref2;
      geom = new CoffeeGL.Geometry();
      geom.indices = [];
      height = height / 2.0;
      geom.v.push(new CoffeeGL.Vertex(new CoffeeGL.Vec3(0, height, 0), new CoffeeGL.Colour.RGBA.WHITE(), new CoffeeGL.Vec3(0, 0, 1.0), new CoffeeGL.Vec2(0.5, 1.0)));
      for (i = _i = 1; 1 <= resolution ? _i <= resolution : _i >= resolution; i = 1 <= resolution ? ++_i : --_i) {
        x = radius * Math.sin(CoffeeGL.degToRad(360.0 / resolution * i));
        z = radius * Math.cos(CoffeeGL.degToRad(360.0 / resolution * i));
        tangent = new CoffeeGL.Vec3(x, 0, z);
        tangent.normalize();
        tangent.cross(new CoffeeGL.Vec3(0, 1, 0));
        geom.v.push(new CoffeeGL.Vertex(new CoffeeGL.Vec3(x, height, z), new CoffeeGL.Colour.RGBA.WHITE(), CoffeeGL.Vec3.normalize(new CoffeeGL.Vec3(x, 1.0, z)), new CoffeeGL.Vec2(i / resolution, 0.0), tangent));
      }
      for (i = _j = 1; 1 <= resolution ? _j <= resolution : _j >= resolution; i = 1 <= resolution ? ++_j : --_j) {
        geom.indices.push(0);
        geom.indices.push(i);
        if (i === resolution) {
          geom.indices.push(1);
        } else {
          geom.indices.push(i + 1);
        }
      }
      for (i = _k = 1; 1 <= segments ? _k <= segments : _k >= segments; i = 1 <= segments ? ++_k : --_k) {
        for (j = _l = 1; 1 <= resolution ? _l <= resolution : _l >= resolution; j = 1 <= resolution ? ++_l : --_l) {
          x = radius * Math.sin(CoffeeGL.degToRad(360.0 / resolution * j));
          z = radius * Math.cos(CoffeeGL.degToRad(360.0 / resolution * j));
          tangent = new CoffeeGL.Vec3(x, 0, z);
          tangent.normalize();
          tangent.cross(new CoffeeGL.Vec3(0, -1, 0));
          geom.v.push(new CoffeeGL.Vertex(new CoffeeGL.Vec3(x, -height * i, z), new CoffeeGL.Colour.RGBA.WHITE(), CoffeeGL.Vec3.normalize(new CoffeeGL.Vec3(x, -1.0, z)), new CoffeeGL.Vec2(j / resolution, i / segments), tangent));
        }
        s = (i - 1) * resolution + 1;
        e = s + resolution;
        for (j = _m = 0, _ref = resolution - 1; 0 <= _ref ? _m <= _ref : _m >= _ref; j = 0 <= _ref ? ++_m : --_m) {
          geom.indices.push(s + j);
          geom.indices.push(e + j);
          if (j === (resolution - 1)) {
            geom.indices.push(e);
          } else {
            geom.indices.push(e + j + 1);
          }
        }
        for (j = _n = 0, _ref1 = resolution - 1; 0 <= _ref1 ? _n <= _ref1 : _n >= _ref1; j = 0 <= _ref1 ? ++_n : --_n) {
          geom.indices.push(s + j);
          if (j === (resolution - 1)) {
            geom.indices.push(e);
            geom.indices.push(s);
          } else {
            geom.indices.push(e + j + 1);
            geom.indices.push(s + j + 1);
          }
        }
      }
      geom.v.push(new CoffeeGL.Vertex(new CoffeeGL.Vec3(0, -height * segments, 0), new CoffeeGL.Colour.RGBA.WHITE(), new CoffeeGL.Vec3(0, 0, -1.0), new CoffeeGL.Vec2(0.5, 1.0)));
      s = (segments * resolution) + 2;
      e = s + resolution - 1;
      for (i = _o = s; s <= e ? _o <= e : _o >= e; i = s <= e ? ++_o : --_o) {
        geom.indices.push(s - 1);
        if (i === e) {
          geom.indices.push(s);
        } else {
          geom.indices.push(i + 1);
        }
        geom.indices.push(i);
      }
      for (i = _p = 0, _ref2 = geom.indices.length - 1; _p <= _ref2; i = _p += 3) {
        geom.faces.push(new CoffeeGL.Triangle(geom.v[geom.indices[i]], geom.v[geom.indices[i + 1]], geom.v[geom.indices[i + 2]]));
      }
      return geom;
    };

    EquatorieString.prototype.update = function(data) {
      var idx, phys, segment, tmatrix, tq, tv, _i, _len, _ref, _results;
      idx = 0;
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        segment = _ref[_i];
        phys = data.segments[idx];
        segment.matrix.identity();
        tq = new CoffeeGL.Quaternion();
        tv = new CoffeeGL.Vec3(phys.rax, phys.ray, phys.raz);
        tq.fromAxisAngle(tv, phys.ra);
        tmatrix = tq.getMatrix4();
        tmatrix.setPos(new CoffeeGL.Vec3(phys.x, phys.y, phys.z));
        segment.matrix.copyFrom(tmatrix);
        _results.push(idx++);
      }
      return _results;
    };

    return EquatorieString;

  })(CoffeeGL.Node);

  module.exports = {
    EquatorieString: EquatorieString
  };

}).call(this);
