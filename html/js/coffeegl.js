;(function(e,t,n){function r(n,i){if(!t[n]){if(!e[n]){var s=typeof require=="function"&&require;if(!i&&s)return s(n,!0);throw new Error("Cannot find module '"+n+"'")}var o=t[n]={exports:{}};e[n][0](function(t){var i=e[n][1][t];return r(i?i:t)},o,o.exports)}return t[n].exports}for(var i=0;i<n.length;i++)r(n[i]);return r})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/

- Resources

* http://www.yuiblog.com/blog/2007/06/12/module-pattern/
* http://www.plexical.com/blog/2012/01/25/writing-coffeescript-for-browser-and-nod/
* https://github.com/field/FieldKit.js
*/


(function() {
  var CoffeeGL, GL, extend, util, _setupFrame;

  CoffeeGL = {};

  GL = {};

  util = require('./util');

  extend = function() {
    var pkg;
    switch (arguments.length) {
      case 1:
        return util.extend(CoffeeGL, arguments[0]);
      case 2:
        pkg = arguments[0];
        if (CoffeeGL[pkg] == null) {
          CoffeeGL[pkg] = {};
        }
        return util.extend(CoffeeGL[pkg], arguments[1]);
    }
  };

  if (typeof window !== "undefined" && window !== null) {
    window.CoffeeGL = CoffeeGL;
  }

  if (typeof window !== "undefined" && window !== null) {
    window.GL = GL;
  }

  extend(require('./app'));

  extend(require('./math'));

  extend(require('./colour'));

  extend(require('./primitives'));

  extend(require('./node'));

  extend(require('./model'));

  extend(require('./shader'));

  extend(require('./request'));

  extend(require('./fbo'));

  extend(require('./texture'));

  extend("Camera", require('./camera'));

  extend(require('./shapes'));

  extend(require('./webgl'));

  extend(require('./util'));

  extend(require('./signal'));

  extend("Light", require('./light'));

  extend(require('./material'));

  extend(require('./error'));

  _setupFrame = function(root) {
    var onEachFrame;
    if (root.webkitRequestAnimationFrame) {
      onEachFrame = function(cb) {
        var _cb;
        _cb = function() {
          cb();
          return webkitRequestAnimationFrame(_cb);
        };
        return _cb();
      };
    } else if (root.mozRequestAnimationFrame) {
      onEachFrame = function(cb) {
        var _cb;
        _cb = function() {
          cb();
          return mozRequestAnimationFrame(_cb);
        };
        return _cb();
      };
    } else {
      onEachFrame = function(cb) {
        return setInterval(cb, 1000 / 60);
      };
    }
    return root.onEachFrame = onEachFrame;
  };

  if (typeof window !== "undefined" && window !== null) {
    _setupFrame(window);
  }

  module.exports = {
    CoffeeGL: CoffeeGL,
    GL: GL
  };

}).call(this);

},{"./util":2,"./app":3,"./math":4,"./colour":5,"./primitives":6,"./node":7,"./model":8,"./shader":9,"./request":10,"./fbo":11,"./texture":12,"./camera":13,"./shapes":14,"./webgl":15,"./signal":16,"./light":17,"./material":18,"./error":19}],2:[function(require,module,exports){
(function(){// Generated by CoffeeScript 1.6.1
(function() {
  var util;

  util = {};

  util.extend = function(obj, source) {
    var i, il, keys, prop, safeHasOwnProperty;
    if (Object.keys) {
      keys = Object.keys(source);
      i = 0;
      il = keys.length;
      while (i < il) {
        prop = keys[i];
        Object.defineProperty(obj, prop, Object.getOwnPropertyDescriptor(source, prop));
        i++;
      }
    } else {
      safeHasOwnProperty = {}.hasOwnProperty;
      for (prop in source) {
        if (safeHasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  };

  util.removeElement = function(element, list) {
    var index;
    index = list.indexOf(element);
    if (index !== -1) {
      list.splice(index, 1);
    }
    return list;
  };

  util.clone = function(obj) {
    var flags, key, newInstance;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = util.clone(obj[key]);
    }
    return newInstance;
  };

  module.exports = util;

}).call(this);

})()
},{}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*                    __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/
*/


(function() {
  var Colour;

  Colour = {};

  Colour.RGBA = (function() {

    function RGBA(r, g, b, a) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
    }

    RGBA.prototype.flatten = function() {
      return [this.r, this.g, this.b, this.a];
    };

    RGBA.WHITE = function() {
      return new Colour.RGBA(1.0, 1.0, 1.0, 1.0);
    };

    return RGBA;

  })();

  Colour.RGB = (function() {

    function RGB(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
    }

    RGB.prototype.flatten = function() {
      return [this.r, this.g, this.b];
    };

    RGB.WHITE = function() {
      return new Colour.RGB(1.0, 1.0, 1.0);
    };

    return RGB;

  })();

  module.exports = {
    Colour: Colour
  };

}).call(this);

},{}],19:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/
*/


(function() {
  var CoffeeGLError, CoffeeGLLog, CoffeeGLWarning, CoffeeGLWarningOnce, cache,
    _this = this,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  cache = [];

  CoffeeGLError = function(msg, obj) {
    var f;
    f = "CoffeeGL Error : " + msg;
    if (obj != null) {
      f += " in " + obj;
    }
    console.error(f);
    throw f;
  };

  CoffeeGLWarning = function(msg, obj) {
    var f;
    f = "CoffeeGL Warning : " + msg;
    if (obj != null) {
      f += " in " + obj;
    }
    return console.warn(f);
  };

  CoffeeGLWarningOnce = function(msg, obj) {
    var f, result;
    result = __indexOf.call(cache, msg) >= 0;
    if (!result) {
      f = "CoffeeGL Warning : " + msg;
      if (obj != null) {
        f += " in " + obj;
      }
      console.warn(f);
      return cache.push(msg);
    }
  };

  CoffeeGLLog = function(msg, obj) {
    var f;
    f = "CoffeeGL Log : " + msg;
    if (obj != null) {
      f += " in " + obj;
    }
    return console.log(f);
  };

  module.exports = {
    CoffeeGLError: CoffeeGLError,
    CoffeeGLWarning: CoffeeGLWarning,
    CoffeeGLLog: CoffeeGLLog,
    CoffeeGLWarningOnce: CoffeeGLWarningOnce
  };

}).call(this);

},{}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/

- Resources

* http://www.yuiblog.com/blog/2007/06/12/module-pattern/
* http://www.plexical.com/blog/2012/01/25/writing-coffeescript-for-browser-and-nod/
* https://github.com/field/FieldKit.js
*/


(function() {
  var App, Colour, Matrix4, OrthoCamera, PerspCamera, Shader, Vec2, Vec3, Vec4, makeMouseEmitter, _ref, _ref1,
    _this = this;

  _ref = require("./math"), Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Vec4 = _ref.Vec4, Matrix4 = _ref.Matrix4;

  Shader = require("./shader").Shader;

  _ref1 = require("./camera"), PerspCamera = _ref1.PerspCamera, OrthoCamera = _ref1.OrthoCamera;

  makeMouseEmitter = require("./signal").makeMouseEmitter;

  Colour = require("./colour").Colour;

  App = (function() {

    function App(element, app_context, init, draw, update, resize, onError, debug) {
      var _this = this;
      this.app_context = app_context;
      this.init = init;
      this.draw = draw;
      this.update = update;
      this.resize = resize;
      this.onError = onError;
      this.debug = debug != null ? debug : false;
      this._resize = function() {
        return App.prototype._resize.apply(_this, arguments);
      };
      this.getDelta = function() {
        return App.prototype.getDelta.apply(_this, arguments);
      };
      this.run = function() {
        return App.prototype.run.apply(_this, arguments);
      };
      this.totalTime = 0.0;
      this.loops = 0;
      this.maxFrameSkip = 10;
      this.nextGameTick = (new Date).getTime();
      this.resources = 0;
      this.startTime = Date.now();
      this.oldTime = this.startTime;
      this.canvas = document.getElementById(element);
      this.height = this.canvas.height;
      this.width = this.canvas.width;
      if (this.debug) {
        this.gl = WebGLDebugUtils.makeDebugContext(this.canvas.getContext("experimental-webgl"));
        console.log("CoffeeGL - creating OpenGL debug context");
      } else {
        this.gl = this.canvas.getContext("experimental-webgl");
      }
      if (!this.gl) {
        if (this.onError != null) {
          this.onError();
        }
        return;
      }
      this._resize();
      this._init();
    }

    App.prototype.run = function() {
      this._draw();
      return this._update(this.getDelta());
    };

    App.prototype._init = function() {
      CoffeeGL.Context = this;
      if (typeof window !== "undefined" && window !== null) {
        window.GL = this.gl;
      }
      if (typeof window !== "undefined" && window !== null) {
        makeMouseEmitter(this);
      }
      if (this.init != null) {
        this.init.call(this.app_context);
      }
      if (typeof window !== "undefined" && window !== null) {
        return window.onEachFrame(this.run);
      }
    };

    App.prototype.getDelta = function() {
      var deltaTime;
      deltaTime = Date.now() - this.oldTime;
      this.oldTime = Date.now();
      return deltaTime;
    };

    App.prototype._resize = function() {
      if (this.canvas) {
        if (this.gl) {
          if (typeof window !== "undefined" && window !== null) {
            window.GL = this.gl;
          }
          if (this.height !== this.canvas.height || this.width !== this.canvas.width) {
            this.height = this.canvas.height;
            this.width = this.canvas.width;
            this.gl.viewportWidth = this.width;
            this.gl.viewportHeight = this.height;
            this.gl.viewport(0, 0, this.gl.viewportWidth, this.gl.viewportHeight);
            if (this.resize != null) {
              return this.resize.call(this.app_context);
            }
          }
        }
      }
    };

    App.prototype._draw = function() {
      CoffeeGL.Context = this;
      if (typeof window !== "undefined" && window !== null) {
        window.GL = this.gl;
      }
      if (this.draw != null) {
        return this.draw.call(this.app_context);
      }
    };

    App.prototype._update = function(dt) {
      if (this.update != null) {
        return this.update.call(this.app_context, dt);
      }
    };

    return App;

  })();

  module.exports = {
    App: App
  };

}).call(this);

},{"./math":4,"./shader":9,"./camera":13,"./signal":16,"./colour":5}],4:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/* 
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/

http://www.flipcode.com/documents/matrfaq.html

  - Thanks: Tojiro - https://github.com/toji/gl-matrix
  - Thanks: Cinder for most of the math!

  TODO - Matrix mult function for vectors as well as scalars and matrices
  TODO - Make functions that multiply other things destructive
*/


(function() {
  var CoffeeGLWarning, EPSILON_VALUE, Matrix3, Matrix4, PI, Quaternion, Vec2, Vec3, Vec4, degToRad, glMatrixArrayType, radToDeg;

  CoffeeGLWarning = require('./error').CoffeeGLWarning;

  if (typeof (typeof Float32Array !== "undefined" && Float32Array !== null)) {
    glMatrixArrayType = Float32Array;
  } else if (typeof (typeof WebGLFloatArray !== "undefined" && WebGLFloatArray !== null)) {
    glMatrixArrayType = WebGLFloatArray;
  } else {
    glMatrixArrayType = Array;
  }

  EPSILON_VALUE = 4.37114e-05;

  PI = 3.14159;

  ({
    sinx_over_x: function(x) {
      if (x * x < 1.19209290e-07) {
        return 1;
      } else {
        return Math.sin(x) / x;
      }
    }
  });

  radToDeg = function(a) {
    return a * 57.2957795;
  };

  degToRad = function(a) {
    return a * 0.017453292523928;
  };

  Vec2 = (function() {

    Vec2.prototype._DIM = 2;

    Vec2.sub = function(a, b) {
      return a.copy()["sub"](b);
    };

    Vec2.add = function(a, b) {
      return a.copy()["add"](b);
    };

    Vec2.div = function(a, b) {
      return a.copy()["div"](b);
    };

    Vec2.mult = function(a, b) {
      return a.copy()["mult"](b);
    };

    Vec2.multScalar = function(a, b) {
      return a.copy()["multScalar"](b);
    };

    Vec2.normalize = function(a) {
      return a.copy()["normalize"]();
    };

    function Vec2(x, y) {
      var _ref;
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      _ref = [x, y], this.x = _ref[0], this.y = _ref[1];
    }

    Vec2.prototype.copy = function() {
      return new Vec2(this.x, this.y);
    };

    Vec2.prototype.length = function() {
      return Math.sqrt(this.lengthSquared());
    };

    Vec2.prototype.lengthSquared = function() {
      return this.x * this.x + this.y * this.y;
    };

    Vec2.prototype.normalize = function() {
      var m;
      m = this.length();
      if (m > 0) {
        this.div(m);
      }
      return this;
    };

    Vec2.prototype.sub = function(v) {
      this.x -= v.x;
      this.y -= v.y;
      return this;
    };

    Vec2.prototype.add = function(v) {
      this.x += v.x;
      this.y += v.y;
      return this;
    };

    Vec2.prototype.dv = function(v) {
      return new Vec2(Math.abs(this.x - v.x)(Math.abs(this.y - v.y)));
    };

    Vec2.prototype.dist = function(v) {
      return Vec2.sub(this, v).length();
    };

    Vec2.prototype.distSquared = function(v) {
      return Vec2.sub(this, v).lengthSquared();
    };

    Vec2.prototype.div = function(n) {
      var _ref;
      _ref = [this.x / n, this.y / n], this.x = _ref[0], this.y = _ref[1];
      return this;
    };

    Vec2.prototype.mult = function(v) {
      var _ref;
      _ref = [this.x * v.x, this.y * v.y], this.x = _ref[0], this.y = _ref[1];
      return this;
    };

    Vec2.prototype.multScalar = function(n) {
      var _ref;
      _ref = [this.x * n, this.y * n], this.x = _ref[0], this.y = _ref[1];
      return this;
    };

    Vec2.prototype.equals = function(v) {
      return this.x === v.x && this.x === v.y;
    };

    Vec2.prototype.dot = function(v) {
      return this.x * v.x + this.y * v.y;
    };

    Vec2.prototype.invalid = function() {
      return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y);
    };

    Vec2.prototype.flatten = function() {
      return [this.x, this.y];
    };

    return Vec2;

  })();

  Vec3 = (function() {

    Vec3.prototype._DIM = 3;

    Vec3.sub = function(a, b) {
      return a.copy()["sub"](b);
    };

    Vec3.add = function(a, b) {
      return a.copy()["add"](b);
    };

    Vec3.cross = function(a, b) {
      return a.copy()["cross"](b);
    };

    Vec3.div = function(a, b) {
      return a.copy()["div"](b);
    };

    Vec3.mult = function(a, b) {
      return a.copy()["mult"](b);
    };

    Vec3.multScalar = function(a, b) {
      return a.copy()["multScalar"](b);
    };

    Vec3.normalize = function(a) {
      return a.copy()["normalize"]();
    };

    function Vec3(x, y, z) {
      var _ref;
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (z == null) {
        z = 0;
      }
      _ref = [x, y, z], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2];
    }

    Vec3.prototype.copy = function() {
      return new Vec3(this.x, this.y, this.z);
    };

    Vec3.prototype.length = function() {
      return Math.sqrt(this.lengthSquared());
    };

    Vec3.prototype.lengthSquared = function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    };

    Vec3.prototype.normalize = function() {
      var m;
      m = this.length();
      if (m > 0) {
        this.div(m);
      }
      return this;
    };

    Vec3.prototype.sub = function(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    };

    Vec3.prototype.add = function(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    };

    Vec3.prototype.cross = function(v) {
      var x, y, z;
      x = this.y * v.z - this.z * v.y;
      y = this.z * v.x - this.x * v.z;
      z = this.x * v.y - this.y * v.x;
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    };

    Vec3.prototype.dv = function(v) {
      return new Vec3(Math.abs(this.x - v.x)(Math.abs(this.y - v.y)(Math.abs(this.z - v.z))));
    };

    Vec3.prototype.dist = function(v) {
      return Vec3.sub(this, v).length();
    };

    Vec3.prototype.distSquared = function(v) {
      return Vec3.sub(this, v).lengthSquared();
    };

    Vec3.prototype.div = function(n) {
      var _ref;
      _ref = [this.x / n, this.y / n, this.z / n], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2];
      return this;
    };

    Vec3.prototype.mult = function(v) {
      var _ref;
      _ref = [this.x * v.x, this.y * v.y, this.z * v.z], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2];
      return this;
    };

    Vec3.prototype.multScalar = function(n) {
      var _ref;
      _ref = [this.x * n, this.y * n, this.z * n], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2];
      return this;
    };

    Vec3.prototype.equals = function(v) {
      return this.x === v.x && this.y === v.y && this.z === v.z;
    };

    Vec3.prototype.dot = function(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    };

    Vec3.prototype.invalid = function() {
      return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y) || this.z === Infinity || isNaN(this.z);
    };

    Vec3.prototype.flatten = function() {
      return [this.x, this.y, this.z];
    };

    return Vec3;

  })();

  Vec4 = (function() {

    Vec4.prototype._DIM = 4;

    Vec4.sub = function(a, b) {
      return a.copy()["sub"](b);
    };

    Vec4.add = function(a, b) {
      return a.copy()["add"](b);
    };

    Vec4.cross = function(a, b) {
      return a.copy()["cross"](b);
    };

    Vec4.div = function(a, b) {
      return a.copy()["div"](b);
    };

    Vec4.mult = function(a, b) {
      return a.copy()["mult"](b);
    };

    Vec4.multScalar = function(a, b) {
      return a.copy()["multScalar"](b);
    };

    Vec4.normalize = function(a) {
      return a.copy()["normalize"]();
    };

    function Vec4(x, y, z, w) {
      var _ref;
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (z == null) {
        z = 0;
      }
      if (w == null) {
        w = 1;
      }
      _ref = [x, y, z, w], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2], this.w = _ref[3];
    }

    Vec4.prototype.copy = function() {
      return new Vec4(this.x, this.y, this.z, this.w);
    };

    Vec4.prototype.length = function() {
      return Math.sqrt(this.lengthSquared());
    };

    Vec4.prototype.lengthSquared = function() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    };

    Vec4.prototype.normalize = function() {
      var m;
      m = this.length();
      if (m > 0) {
        this.div(m);
      }
      return this;
    };

    Vec4.prototype.toNormal = function() {
      var m;
      m = this.length;
      if (m > 0) {
        return this.div(m);
      }
    };

    Vec4.prototype.sub = function(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;
      return this;
    };

    Vec4.prototype.equals = function(v) {
      return this.x === v.x && this.y === v.y && this.z === v.z && this.w === v.w;
    };

    Vec4.prototype.add = function(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;
      return this;
    };

    Vec4.prototype.cross = function(v) {
      var x, y, z;
      x = this.y * v.z - this.z * v.y;
      y = this.z * v.x - this.x * v.z;
      z = this.x * v.y - this.y * v.x;
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    };

    Vec4.prototype.dv = function(v) {
      return new Vec4(Math.abs(this.x - v.x)(Math.abs(this.y - v.y)(Math.abs(this.z - v.z)(Math.abs(this.w - v.w)))));
    };

    Vec4.prototype.dist = function(v) {
      return Vec4.sub(this, v).length();
    };

    Vec4.prototype.distSquared = function(v) {
      return Vec4.sub(this, v).lengthSquared();
    };

    Vec4.prototype.div = function(n) {
      var _ref;
      _ref = [this.x / n, this.y / n, this.z / n, this.w / n], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2], this.w = _ref[3];
      return this;
    };

    Vec4.prototype.mult = function(v) {
      var _ref;
      _ref = [this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2], this.w = _ref[3];
      return this;
    };

    Vec4.prototype.multScalar = function(n) {
      var _ref;
      _ref = [this.x * n, this.y * n, this.z * n, this.w * n], this.x = _ref[0], this.y = _ref[1], this.z = _ref[2], this.w = _ref[3];
      return this;
    };

    Vec4.prototype.dot = function(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    };

    Vec4.prototype.invalid = function() {
      return (this.x === Infinity) || isNaN(this.x) || this.y === Infinity || isNaN(this.y) || this.z === Infinity || isNaN(this.z) || this.w === Infinity || isNaN(this.w);
    };

    Vec4.prototype.flatten = function() {
      return [this.x, this.y, this.z, this.w];
    };

    return Vec4;

  })();

  Matrix3 = (function() {

    Matrix3.prototype._DIM = 3;

    Matrix3.addScalar = function(a, b) {
      return a.copy()["addScalar"](b);
    };

    Matrix3.subScalar = function(a, b) {
      return a.copy()["subScalar"](b);
    };

    Matrix3.multScalar = function(a, b) {
      return a.copy()["multScalar"](b);
    };

    Matrix3.divScalar = function(a, b) {
      return a.copy()["divScalar"](b);
    };

    Matrix3.mult = function(a, b) {
      return a.copy()["mult"](b);
    };

    Matrix3.invert = function(a) {
      return a["_invert"]();
    };

    Matrix3.multVec3 = function(m, v) {
      var tv;
      tv = v.copy();
      m.multVec3(tv);
      return tv;
    };

    Matrix3.transpose = function(a) {
      return a["_transpose"]();
    };

    function Matrix3(a) {
      if (a == null) {
        a = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      }
      this.a = new glMatrixArrayType(a);
    }

    Matrix3.prototype.copy = function() {
      return new Matrix4(this.a);
    };

    Matrix3.prototype.copyFrom = function(a) {
      var i, _i;
      for (i = _i = 0; _i <= 9; i = ++_i) {
        this.a[i] = a.a[i];
      }
      return this;
    };

    Matrix3.prototype.multScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num * n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix3.prototype.addScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num + n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix3.prototype.subScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num - n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix3.prototype.divScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num / n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix3.prototype.toIdentity = function() {
      this.a.set([1, 0, 0, 0, 1, 0, 0, 0, 1]);
      return this;
    };

    Matrix3.prototype.at = function(r, c) {
      return this.a[r * 3 + c];
    };

    Matrix3.prototype.mult = function(m) {
      var a;
      a = new Matrix3();
      a.a[0] = this.a[0] * m.a[0] + this.a[3] * m.a[1] + this.a[6] * m.a[2];
      a.a[1] = this.a[1] * m.a[0] + this.a[5] * m.a[1] + this.a[9] * m.a[2];
      a.a[2] = this.a[2] * m.a[0] + this.a[6] * m.a[1] + this.a[10] * m.a[2];
      a.a[3] = this.a[0] * m.a[3] + this.a[3] * m.a[4] + this.a[6] * m.a[5];
      a.a[4] = this.a[1] * m.a[3] + this.a[4] * m.a[4] + this.a[7] * m.a[5];
      a.a[5] = this.a[2] * m.a[3] + this.a[5] * m.a[4] + this.a[8] * m.a[5];
      a.a[6] = this.a[0] * m.a[6] + this.a[4] * m.a[7] + this.a[8] * m.a[8];
      a.a[7] = this.a[1] * m.a[6] + this.a[5] * m.a[7] + this.a[9] * m.a[8];
      a.a[8] = this.a[2] * m.a[6] + this.a[6] * m.a[7] + this.a[10] * m.a[8];
      this.copyFrom(a);
      return this;
    };

    Matrix3.prototype.multVec3 = function(v) {
      var x, y, z;
      if (v._DIM !== 3) {
        CoffeeGLWarning("Mismatched vector and matrix dimensions");
        return;
      }
      x = this.a[0] * v.x + this.a[3] * v.y + this.a[6] * v.z;
      y = this.a[1] * v.x + this.a[4] * v.y + this.a[7] * v.z;
      z = this.a[2] * v.x + this.a[5] * v.y + this.a[8] * v.z;
      v.x = x;
      v.y = y;
      v.z = z;
      return this;
    };

    Matrix3.prototype.at = function(r, c) {
      return this.a[c * Matrix3.DIM + r];
    };

    Matrix3.prototype.getCol = function(c) {
      c = c * Matrix3.DIM;
      return Vec3(this.a[c + 0](this.a[c + 1](this.a[c + 2])));
    };

    Matrix3.prototype.getRow = function(r) {
      return Vec3(this.a[r + 0](this.a[r + 3](this.a[r + 6])));
    };

    Matrix3.prototype._invert = function() {
      var det, epsilon, inv, invDet;
      inv = new Matrix3();
      epsilon = 4.37114e-05;
      inv.a[0] = this.a[4] * this.a[8] - this.a[5] * this.a[7];
      inv.a[1] = this.a[2] * this.a[7] - this.a[1] * this.a[8];
      inv.a[2] = this.a[1] * this.a[5] - this.a[2] * this.a[4];
      inv.a[3] = this.a[5] * this.a[6] - this.a[3] * this.a[8];
      inv.a[4] = this.a[0] * this.a[8] - this.a[2] * this.a[6];
      inv.a[5] = this.a[2] * this.a[3] - this.a[0] * this.a[5];
      inv.a[6] = this.a[3] * this.a[7] - this.a[4] * this.a[6];
      inv.a[7] = this.a[1] * this.a[6] - this.a[0] * this.a[7];
      inv.a[8] = this.a[0] * this.a[4] - this.a[1] * this.a[3];
      det = this.a[0] * inv.a[0] + this.a[1] * inv.a[3] + this.a[2] * inv.a[6];
      if (Math.abs(det) > epsilon) {
        invDet = 1.0 / det;
        inv.multScalar(invDet);
      }
      return inv;
    };

    Matrix3.prototype.invert = function() {
      this.copyFrom(this._invert());
      return this;
    };

    Matrix3.prototype._transpose = function() {
      return new Matrix3([this.a[0], this.a[3], this.a[6], this.a[1], this.a[4], this.a[7], this.a[2], this.a[5], this.a[8]]);
    };

    Matrix3.prototype.transpose = function() {
      this.copyFrom(this._transpose());
      return this;
    };

    Matrix3.prototype.print = function() {
      console.log(this.a[0] + "," + this.a[3] + "," + this.a[6]);
      console.log(this.a[1] + "," + this.a[4] + "," + this.a[7]);
      return console.log(this.a[2] + "," + this.a[5] + "," + this.a[8]);
    };

    Matrix3.prototype.rotate = function(v, a) {
      var c, r, s;
      r = new Matrix4();
      s = Math.sin(a);
      c = Math.cos(a);
      v.normalize();
      r.a[0] = v.x * v.x * (1 - c) + c;
      r.a[1] = v.x * v.y * (1 - c) + v.z * s;
      r.a[2] = v.x * v.z * (1 - c) - v.y * s;
      r.a[3] = v.x * v.y * (1 - c) - v.z * s;
      r.a[4] = v.y * v.y * (1 - c) + c;
      r.a[5] = v.y * v.z * (1 - c) + v.x * s;
      r.a[6] = v.x * v.z * (1 - c) + v.y * s;
      r.a[7] = v.y * v.z * (1 - c) - v.x * s;
      r.a[8] = v.z * v.z * (1 - c) + c;
      this.mult(r);
      return this;
    };

    Matrix3.prototype.scale = function(v) {
      var r;
      r = new Matrix3();
      r.a[0] = v.x;
      r.a[4] = v.y;
      r.a[8] = v.z;
      this.mult(r);
      return this;
    };

    return Matrix3;

  })();

  Matrix4 = (function() {

    Matrix4.prototype._DIM = 4;

    Matrix4.addScalar = function(a, b) {
      return a.copy()["addScalar"](b);
    };

    Matrix4.subScalar = function(a, b) {
      return a.copy()["subScalar"](b);
    };

    Matrix4.multScalar = function(a, b) {
      return a.copy()["multScalar"](b);
    };

    Matrix4.divScalar = function(a, b) {
      return a.copy()["divScalar"](b);
    };

    Matrix4.mult = function(a, b) {
      return a.copy()["mult"](b);
    };

    Matrix4.invert = function(a) {
      return a["_invert"]();
    };

    Matrix4.transpose = function(a) {
      return a["_transpose"]();
    };

    Matrix4.multVec3 = function(m, v) {
      var tv;
      tv = v.copy();
      m.multVec3(tv);
      return tv;
    };

    Matrix4.multVec4 = function(m, v) {
      var tv;
      tv = v.copy();
      m.multVec4(tv);
      return tv;
    };

    function Matrix4(a) {
      if (a == null) {
        a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }
      this.a = new glMatrixArrayType(a);
    }

    Matrix4.prototype.copy = function() {
      return new Matrix4(this.a);
    };

    Matrix4.prototype.copyFrom = function(a) {
      var i, _i;
      for (i = _i = 0; _i <= 15; i = ++_i) {
        this.a[i] = a.a[i];
      }
      return this;
    };

    Matrix4.prototype.multScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num * n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix4.prototype.addScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num + n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix4.prototype.subScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num - n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix4.prototype.divScalar = function(n) {
      var num;
      this.a = (function() {
        var _i, _len, _ref, _results;
        _ref = this.a;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          num = _ref[_i];
          _results.push(num / n);
        }
        return _results;
      }).call(this);
      return this;
    };

    Matrix4.prototype.toIdentity = function() {
      this.a.set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
      return this;
    };

    Matrix4.prototype.at = function(r, c) {
      return this.a[r * 4 + c];
    };

    Matrix4.prototype.getMatrix3 = function() {
      return new Matrix3([this.a[0], this.a[1], this.a[2], this.a[4], this.a[5], this.a[6], this.a[8], this.a[9], this.a[10]]);
    };

    Matrix4.prototype.mult = function(m) {
      var a;
      a = new Matrix4();
      a.a[0] = this.a[0] * m.a[0] + this.a[4] * m.a[1] + this.a[8] * m.a[2] + this.a[12] * m.a[3];
      a.a[1] = this.a[1] * m.a[0] + this.a[5] * m.a[1] + this.a[9] * m.a[2] + this.a[13] * m.a[3];
      a.a[2] = this.a[2] * m.a[0] + this.a[6] * m.a[1] + this.a[10] * m.a[2] + this.a[14] * m.a[3];
      a.a[3] = this.a[3] * m.a[0] + this.a[7] * m.a[1] + this.a[11] * m.a[2] + this.a[15] * m.a[3];
      a.a[4] = this.a[0] * m.a[4] + this.a[4] * m.a[5] + this.a[8] * m.a[6] + this.a[12] * m.a[7];
      a.a[5] = this.a[1] * m.a[4] + this.a[5] * m.a[5] + this.a[9] * m.a[6] + this.a[13] * m.a[7];
      a.a[6] = this.a[2] * m.a[4] + this.a[6] * m.a[5] + this.a[10] * m.a[6] + this.a[14] * m.a[7];
      a.a[7] = this.a[3] * m.a[4] + this.a[7] * m.a[5] + this.a[11] * m.a[6] + this.a[15] * m.a[7];
      a.a[8] = this.a[0] * m.a[8] + this.a[4] * m.a[9] + this.a[8] * m.a[10] + this.a[12] * m.a[11];
      a.a[9] = this.a[1] * m.a[8] + this.a[5] * m.a[9] + this.a[9] * m.a[10] + this.a[13] * m.a[11];
      a.a[10] = this.a[2] * m.a[8] + this.a[6] * m.a[9] + this.a[10] * m.a[10] + this.a[14] * m.a[11];
      a.a[11] = this.a[3] * m.a[8] + this.a[7] * m.a[9] + this.a[11] * m.a[10] + this.a[15] * m.a[11];
      a.a[12] = this.a[0] * m.a[12] + this.a[4] * m.a[13] + this.a[8] * m.a[14] + this.a[12] * m.a[15];
      a.a[13] = this.a[1] * m.a[12] + this.a[5] * m.a[13] + this.a[9] * m.a[14] + this.a[13] * m.a[15];
      a.a[14] = this.a[2] * m.a[12] + this.a[6] * m.a[13] + this.a[10] * m.a[14] + this.a[14] * m.a[15];
      a.a[15] = this.a[3] * m.a[12] + this.a[7] * m.a[13] + this.a[11] * m.a[14] + this.a[15] * m.a[15];
      this.copyFrom(a);
      return this;
    };

    Matrix4.prototype.multVec3 = function(v) {
      var w, x, y, z;
      if (v._DIM !== 3) {
        CoffeeGLWarning("Mismatched vector and matrix dimensions");
        return;
      }
      x = this.a[0] * v.x + this.a[4] * v.y + this.a[8] * v.z + this.a[12];
      y = this.a[1] * v.x + this.a[5] * v.y + this.a[9] * v.z + this.a[13];
      z = this.a[2] * v.x + this.a[6] * v.y + this.a[10] * v.z + this.a[14];
      w = this.a[3] * v.x + this.a[7] * v.y + this.a[11] * v.z + this.a[15];
      v.x = x / w;
      v.y = y / w;
      v.z = z / w;
      return this;
    };

    Matrix4.prototype.multVec4 = function(v) {
      var w, x, y, z;
      if (v._DIM !== 4) {
        CoffeeGLWarning("Mismatched vector and matrix dimensions");
        return;
      }
      x = this.a[0] * v.x + this.a[4] * v.y + this.a[8] * v.z + this.a[12] * v.w;
      y = this.a[1] * v.x + this.a[5] * v.y + this.a[9] * v.z + this.a[13] * v.w;
      z = this.a[2] * v.x + this.a[6] * v.y + this.a[10] * v.z + this.a[14] * v.w;
      w = this.a[3] * v.x + this.a[7] * v.y + this.a[11] * v.z + this.a[15] * v.w;
      v.x = x;
      v.y = y;
      v.z = z;
      v.w = w;
      return this;
    };

    Matrix4.prototype.at = function(r, c) {
      return this.a[c * Matrix4.DIM + r];
    };

    Matrix4.prototype.getCol = function(c) {
      c = c * Matrix4.DIM;
      return Vec4(this.a[c + 0](this.a[c + 1](this.a[c + 2](this.a[c + 3]))));
    };

    Matrix4.prototype.getRow = function(r) {
      return Vec4(this.a[r + 0](this.a[r + 4](this.a[r + 8](this.a[r + 12]))));
    };

    Matrix4.prototype._invert = function() {
      var a0, a1, a2, a3, a4, a5, b0, b1, b2, b3, b4, b5, det, epsilon, inv, invDet;
      inv = new Matrix4();
      epsilon = 4.37114e-05;
      a0 = this.a[0] * this.a[5] - this.a[1] * this.a[4];
      a1 = this.a[0] * this.a[6] - this.a[2] * this.a[4];
      a2 = this.a[0] * this.a[7] - this.a[3] * this.a[4];
      a3 = this.a[1] * this.a[6] - this.a[2] * this.a[5];
      a4 = this.a[1] * this.a[7] - this.a[3] * this.a[5];
      a5 = this.a[2] * this.a[7] - this.a[3] * this.a[6];
      b0 = this.a[8] * this.a[13] - this.a[9] * this.a[12];
      b1 = this.a[8] * this.a[14] - this.a[10] * this.a[12];
      b2 = this.a[8] * this.a[15] - this.a[11] * this.a[12];
      b3 = this.a[9] * this.a[14] - this.a[10] * this.a[13];
      b4 = this.a[9] * this.a[15] - this.a[11] * this.a[13];
      b5 = this.a[10] * this.a[15] - this.a[11] * this.a[14];
      det = a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0;
      if (Math.abs(det) > epsilon) {
        inv.a[0] = +this.a[5] * b5 - this.a[6] * b4 + this.a[7] * b3;
        inv.a[4] = -this.a[4] * b5 + this.a[6] * b2 - this.a[7] * b1;
        inv.a[8] = +this.a[4] * b4 - this.a[5] * b2 + this.a[7] * b0;
        inv.a[12] = -this.a[4] * b3 + this.a[5] * b1 - this.a[6] * b0;
        inv.a[1] = -this.a[1] * b5 + this.a[2] * b4 - this.a[3] * b3;
        inv.a[5] = +this.a[0] * b5 - this.a[2] * b2 + this.a[3] * b1;
        inv.a[9] = -this.a[0] * b4 + this.a[1] * b2 - this.a[3] * b0;
        inv.a[13] = +this.a[0] * b3 - this.a[1] * b1 + this.a[2] * b0;
        inv.a[2] = +this.a[13] * a5 - this.a[14] * a4 + this.a[15] * a3;
        inv.a[6] = -this.a[12] * a5 + this.a[14] * a2 - this.a[15] * a1;
        inv.a[10] = +this.a[12] * a4 - this.a[13] * a2 + this.a[15] * a0;
        inv.a[14] = -this.a[12] * a3 + this.a[13] * a1 - this.a[14] * a0;
        inv.a[3] = -this.a[9] * a5 + this.a[10] * a4 - this.a[11] * a3;
        inv.a[7] = +this.a[8] * a5 - this.a[10] * a2 + this.a[11] * a1;
        inv.a[11] = -this.a[8] * a4 + this.a[9] * a2 - this.a[11] * a0;
        inv.a[15] = +this.a[8] * a3 - this.a[9] * a1 + this.a[10] * a0;
      }
      invDet = 1.0 / det;
      inv.multScalar(invDet);
      return inv;
    };

    Matrix4.prototype.invert = function() {
      this.copyFrom(this._invert());
      return this;
    };

    Matrix4.prototype.transpose = function() {
      this.copyFrom(this._transpose());
      return this;
    };

    Matrix4.prototype._transpose = function() {
      return new Matrix4([this.a[0], this.a[4], this.a[8], this.a[12], this.a[1], this.a[5], this.a[9], this.a[13], this.a[2], this.a[6], this.a[10], this.a[14], this.a[3], this.a[7], this.a[11], this.a[15]]);
    };

    Matrix4.prototype.translate = function(v) {
      var r;
      if (v._DIM === 3 || v._DIM === _DIM) {
        r = new Matrix4();
        r.a[12] = v.x;
        r.a[13] = v.y;
        r.a[14] = v.z;
        this.mult(r);
      } else {
        CoffeeGLWarning("Mismatched vector and matrix dimensions");
      }
      return this;
    };

    Matrix4.prototype.print = function() {
      console.log(this.a[0] + "," + this.a[4] + "," + this.a[8] + "," + this.a[12]);
      console.log(this.a[1] + "," + this.a[5] + "," + this.a[9] + "," + this.a[13]);
      console.log(this.a[2] + "," + this.a[6] + "," + this.a[10] + "," + this.a[14]);
      return console.log(this.a[3] + "," + this.a[7] + "," + this.a[11] + "," + this.a[15]);
    };

    Matrix4.prototype.lookAt = function(eye, look, up) {
      var f, m, s, t, u, w;
      f = Vec3.sub(look, eye);
      f.normalize();
      u = up.copy();
      u.normalize();
      s = Vec3.cross(f, u);
      w = Vec3.cross(s, f);
      m = new Matrix4([s.x, u.x, -f.x, 0, s.y, u.y, -f.y, 0, s.z, u.z, -f.z, 0, 0, 0, 0, 1]);
      t = new Matrix4([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, -eye.x, -eye.y, -eye.z, 1]);
      m.mult(t);
      this.copyFrom(m);
      return this;
    };

    Matrix4.prototype.makePerspective = function(fovy, aspect, znear, zfar) {
      var xmax, xmin, ymax, ymin;
      ymax = znear * Math.tan(fovy * Math.PI / 360.0);
      ymin = -ymax;
      xmin = ymin * aspect;
      xmax = ymax * aspect;
      this.makeFrustum(xmin, xmax, ymin, ymax, znear, zfar);
      return this;
    };

    Matrix4.prototype.makeFrustum = function(left, right, bottom, top, znear, zfar) {
      var a, b, c, d, x, y;
      x = 2 * znear / (right - left);
      y = 2 * znear / (top - bottom);
      a = (right + left) / (right - left);
      b = (top + bottom) / (top - bottom);
      c = -(zfar + znear) / (zfar - znear);
      d = -2 * zfar * znear / (zfar - znear);
      this.a = new Float32Array([x, 0, 0, 0, 0, y, 0, 0, a, b, c, -1, 0, 0, d, 0]);
      return 0;
    };

    Matrix4.prototype.makeOrtho = function(left, right, bottom, top, znear, zfar) {
      var tx, ty, tz;
      tx = -(right + left) / (right - left);
      ty = -(top + bottom) / (top - bottom);
      tz = -(zfar + znear) / (zfar - znear);
      this.a = new Float32Array([2 / (right - left), 0, 0, tx, 0, 2 / (top - bottom), 0, ty, 0, 0, -2 / (zfar - znear), tz, 0, 0, 0, 1]);
      return this;
    };

    Matrix4.prototype.rotate = function(v, a) {
      var c, r, s;
      r = new Matrix4();
      s = Math.sin(a);
      c = Math.cos(a);
      v.normalize();
      r.a[0] = v.x * v.x * (1 - c) + c;
      r.a[1] = v.x * v.y * (1 - c) + v.z * s;
      r.a[2] = v.x * v.z * (1 - c) - v.y * s;
      r.a[4] = v.x * v.y * (1 - c) - v.z * s;
      r.a[5] = v.y * v.y * (1 - c) + c;
      r.a[6] = v.y * v.z * (1 - c) + v.x * s;
      r.a[8] = v.x * v.z * (1 - c) + v.y * s;
      r.a[9] = v.y * v.z * (1 - c) - v.x * s;
      r.a[10] = v.z * v.z * (1 - c) + c;
      this.mult(r);
      return this;
    };

    Matrix4.prototype.scale = function(v) {
      var r;
      r = new Matrix4();
      r.a[0] = v.x;
      r.a[5] = v.y;
      r.a[10] = v.z;
      this.mult(r);
      return this;
    };

    return Matrix4;

  })();

  Quaternion = (function() {

    Quaternion.addScalar = function(a, b) {
      return a.copy()["addScalar"](b);
    };

    Quaternion.subScalar = function(a, b) {
      return a.copy()["subScalar"](b);
    };

    Quaternion.multScalar = function(a, b) {
      return a.copy()["multScalar"](b);
    };

    Quaternion.divScalar = function(a, b) {
      return a.copy()["divScalar"](b);
    };

    Quaternion.divScalar = function(a, b) {
      return a.copy()["mult"](b);
    };

    Quaternion.transVec3 = function(q, v) {
      var tv;
      tv = v.copy();
      q.transVec3(tv);
      return tv;
    };

    function Quaternion(v, w) {
      if ((v == null) || (w == null)) {
        this.v = new Vec3(0, 0, 0);
        this.w = 1;
      } else {
        this.v = v.copy();
        this.w = w;
      }
    }

    Quaternion.prototype.copy = function() {
      return new Quaternion(this.v, this.w);
    };

    Quaternion.prototype.axis = function() {
      var ca, invlen;
      ca = w;
      invlen = 1.0 / Math.sqrt(1.0 - ca * ca);
      return v.mult(invlen);
    };

    Quaternion.prototype.angle = function() {
      var ca;
      ca = w;
      return Math.acos(ca) * 2;
    };

    Quaternion.prototype.pitch = function() {
      return Math.atan2(2 * (this.v.y * this.v.z + this.w * this.v.x), this.w * this.w - this.v.x * this.v.x - this.v.y * this.v.y + this.v.z * this.v.z);
    };

    Quaternion.prototype.yaw = function() {
      return Math.sin(-2 * (this.v.x * this.v.z - this.w * this.v.y));
    };

    Quaternion.prototype.roll = function() {
      return Math.atan2(2 * (this.v.x * this.v.y + this.w * this.v.z), this.w * this.w + this.v.x * this.v.x - this.v.y * this.v.y - this.v.z * this.v.z);
    };

    Quaternion.prototype.dot = function(a) {
      return this.w * a.w + v.dot(a.v);
    };

    Quaternion.prototype.length = function() {
      return Math.sqrt(this.w * this.w + this.v.lengthSquared());
    };

    Quaternion.prototype.lengthSquared = function() {
      return w * w + this.v.lengthSquared();
    };

    Quaternion.prototype.inverse = function() {
      var norm, normRecip;
      norm = this.w * this.w + this.v.x * this.v.x + this.v.y * this.v.y + this.v.z * this.v.z;
      if (Math.abs(norm) < EPSILON_VALUE) {
        return this.identity();
      }
      normRecip = 1.0 / norm;
      this.w = normRecip * w;
      return this.v.multScalar(-normRecip);
    };

    Quaternion.prototype.add = function(q) {
      this.w += q.w;
      this.v.x += q.v.x;
      this.v.y += q.v.y;
      this.v.z += q.v.z;
      return this;
    };

    Quaternion.prototype.sub = function(q) {
      this.w -= q.w;
      this.v.x -= q.v.x;
      this.v.y -= q.v.y;
      this.v.z -= q.v.z;
      return this;
    };

    Quaternion.prototype.multiply = function(q) {
      return this.mult(q);
    };

    Quaternion.prototype.mult = function(q) {
      this.w = this.w * q.w - this.v.x * q.v.x - this.v.y * q.v.y - this.v.z * q.v.z;
      this.v.x = q.w * this.v.x + q.v.x * this.w + q.v.y * this.v.z - q.v.z * this.v.y;
      this.v.y = q.w * this.v.y + q.v.y * this.w + q.v.z * this.v.x - q.v.x * this.v.z;
      this.v.z = q.w * this.v.z + q.v.z * this.w + q.v.x * this.v.y - q.v.y * this.v.x;
      return this;
    };

    Quaternion.prototype.multScalar = function(s) {
      this.w = this.w * s;
      this.v.multScalar(s);
      return this;
    };

    Quaternion.prototype.transVec3 = function(v) {
      var cm, pm, vm, x, y, z;
      vm = 2 * (this.v.x * v.x + this.v.y * v.y + this.v.z * v.z);
      cm = 2 * this.w;
      pm = cm * this.w - 1.0;
      x = pm * v.x + vm * this.v.x + cm * (this.v.y * v.z - this.v.z * v.y);
      y = pm * v.y + vm * this.v.y + cm * (this.v.z * v.x - this.v.x * v.z);
      z = pm * v.z + vm * this.v.z + cm * (this.v.x * v.y - this.v.y * v.x);
      v.x = x;
      v.y = y;
      v.z = z;
      return this;
    };

    Quaternion.prototype.normalize = function() {
      var len;
      len = this.length();
      if (len > 0) {
        this.w /= len;
        this.v.multScalar(1.0 / len);
      } else {
        this.w = 1.0;
        this.v.x = v.y = v.z = 0.0;
      }
      return this;
    };

    Quaternion.prototype.log = function() {
      var k, sintheta, t, theta;
      t = 1.0;
      if (this.w < t) {
        t = this.w;
      }
      theta = Math.acos(t);
      if (theta === 0) {
        return new Quaternion(this.v, 0);
      }
      sintheta = Math.sin(theta);
      k = theta / sintheta;
      if (Math.abs(sintheta) < 1 && Math.abs(theta) >= 3.402823466e+38 * Math.abs(sintheta)) {
        k = 1;
      }
      return new Quaternion(new Vec3(this.v.x * k, this.v.y * k, v.z * k), 0);
    };

    Quaternion.prototype.exp = function() {
      var costheta, k, sintheta, theta;
      theta = this.v.length();
      sintheta = sin(theta);
      k = sintheta / theta;
      if (Math.abs(theta) < 1 && Math.abs(sintheta) >= 3.402823466e+38 * Math.abs(theta)) {
        k = 1;
      }
      costheta = Math.cos(theta);
      return new Quaternion(new Vec3(this.v.x * k, this.v.y * k, v.z * k), costheta);
    };

    Quaternion.prototype.invert = function() {
      var qdot;
      qdot = this.dot();
      this.v = new Vec3(-this.v.x / qdot, -this.v.y / qdot, -this.v.z / qdot);
      this.w = this.w / qdot;
      return this;
    };

    Quaternion.prototype.fromTo = function(f, t) {
      var axis;
      axis = Vec3.cross(f, t);
      this.w = f.dot(t);
      this.v.x = axis.x;
      this.v.y = axis.y;
      this.v.z = axis.z;
      this.normalize();
      this.w += 1.0;
      if (this.w <= EPSILON_VALUE) {
        if (f.z * f.z > f.x * f.x) {
          this.w = 0.0;
          this.v.x = 0;
          this.v.y = f.z;
          this.v.z = -f.y;
        } else {
          this.w = 0.0;
          this.v.x = f.y;
          this.v.y = -f.x;
          this.v.z = 0.0;
        }
        this.normalize();
      }
      return this;
    };

    Quaternion.prototype.fromAxisAngle = function(a, r) {
      this.w = Math.cos(r / 2);
      this.v = Vec3.normalize(a).multScalar(Math.sin(r / 2));
      return this;
    };

    Quaternion.prototype.fromRotations = function(x, y, z) {
      var cx, cy, cz, sx, sy, sz;
      x *= 0.5;
      y *= 0.5;
      z *= 0.5;
      cx = Math.cos(x);
      sx = Math.sin(x);
      cy = Math.cos(y);
      sy = Math.sin(y);
      cz = Math.cos(z);
      sz = Math.sin(z);
      this.w = cx * cy * cz - sx * sy * sz;
      this.v.x = sx * cy * cx + cx * sy * sz;
      this.v.y = cx * sy * cz - sx * cy * sz;
      this.v.z = cx * cy * sz + sx * sy * cx;
      return this;
    };

    Quaternion.prototype.getAxisAngle = function() {
      var ca, invlen, r;
      ca = this.w;
      r = Math.acos(ca) * 2;
      invlen = 1.0 / Math.sqrt(1.0 - ca * ca);
      return [new Vec3(this.v.x * invlen, this.v.y * invlen, this.v.z * invlen), r];
    };

    Quaternion.prototype.getMatrix4 = function() {
      var wx, wy, wz, xs, xx, xy, xz, ys, yy, yz, zs, zz;
      xs = this.v.x + this.v.x;
      ys = this.v.y + this.v.y;
      zs = this.v.z + this.v.z;
      wx = this.w * xs;
      wy = this.w * ys;
      wz = this.w * zs;
      xx = this.v.x * xs;
      xy = this.v.x * ys;
      xz = this.v.x * zs;
      yy = this.v.y * ys;
      yz = this.v.y * zs;
      zz = this.v.z * zs;
      return new Matrix4([1.0 - (yy + zz), xy + wz, xz - wy, 0, xy - wz, 1.0 - (xx + zz), yz + wx, 0, xz + wy, yz - wx, 1.0 - (xx + yy), 0, 0, 0, 0, 1.0]);
    };

    Quaternion.prototype.lerp = function(t, end) {
      var costheta, result;
      costheta = end.dot();
      result = Quaternion.multScalar(end, t);
      if (costheta >= EPSILON_VALUE) {
        result.add(result.multScalar(1.0 - t));
      } else {
        result.add(result.multScalar(t - 1.0));
      }
      return result;
    };

    Quaternion.prototype.slerpShortestUnenforced = function(t, end) {
      var a, d, e, lengthD, lengthS, q, s, st;
      d = this.copy();
      d.sub(end);
      lengthD = Math.sqrt(this.dot(end));
      st = this.copy();
      st.add(end);
      lengthS = Math.sqrt(st.dot(st));
      a = 2 * Math.atan2(lengthD, lengthS);
      s = 1 - t;
      q = this.copy();
      q.multScalar(sinx_over_x(s * a) / sinx_over_x(a) * s);
      e = end.copy();
      e.multScalar(sinx_over_x(t * a) / sinx_over_x(a) * t);
      q.add(e);
      q.normalize();
      return q;
    };

    Quaternion.prototype.slerp = function(t, end) {
      var cosTheta, e, endInterp, q, recipSinTheta, startInterp, theta;
      cosTheta = this.dot(end);
      if (cosTheta >= EPSILON) {
        if (1.0 - cosTheta > EPSILON) {
          theta = Math.acos(cosTheta);
          recipSinTheta = 1.0 / Math.sin(theta);
          startInterp = Math.sin((1.0 - t) * theta) * recipSinTheta;
          endInterp = Math.sin(t * theta) * recipSinTheta;
        } else {
          startInterp = 1.0 - t;
          endInterp = t;
        }
      } else {
        if (1.0 + cosTheta > EPSILON) {
          theta = Math.acos(-cosTheta);
          recipSinTheta = 1.0 / Math.sin(theta);
          startInterp = Math.sin((t - 1.0) * theta) * recipSinTheta;
          endInterp = Math.sin(t * theta) * recipSinTheta;
        } else {
          startInterp = t(-1.0);
          endInterp = t;
        }
      }
      q = this.copy();
      q.mult(startInterp);
      e = end.copy();
      e.mult(endInterp);
      q.add(e);
      return q;
    };

    Quaternion.prototype.fromMatrix4 = function(m) {
      var a, b, i, j, k, recip, s, trace;
      trace = m.a[0] + m.a[5] + m.a[10];
      if (trace > 0.0) {
        s = Math.sqrt(trace + 1.0);
        this.w = s * 0.5;
        recip = 0.5 / s;
        this.v.x = (m.at(2, 1) - m.at(1, 2)) * recip;
        this.v.y = (m.at(0, 2) - m.at(2, 0)) * recip;
        this.v.z = (m.at(1, 0) - m.at(0, 1)) * recip;
      } else {
        i = 0;
        if (m.at(1, 1) > m.at(0, 0)) {
          i = 1;
        }
        if (m.at(2, 2) > m.at(i, i)) {
          i = 2;
        }
        j = (i + 1) % 3;
        k = (j + 1) % 3;
        s = Math.sqrt(m.at(i, i) - m.at(j, j) - m.at(k, k) + 1.0);
        if (i === 0) {
          this.v.x = 0.5 * s;
        } else if (i === 1) {
          this.v.y = 0.5 * s;
        } else {
          this.v.z = 0.5 * s;
        }
        recip = 0.5 / s;
        this.w = (m.at(k, j) - m.at(j, k)) * recip;
        a = (m.at(j, i) + m.at(i, j)) * recip;
        b = (m.at(k, i) + m.at(i, k)) * recip;
        if (j === 0) {
          this.v.x = a;
        } else if (j === 1) {
          this.v.y = a;
        } else {
          this.v.z = a;
        }
        if (k === 0) {
          this.v.x = b;
        } else if (k === 1) {
          this.v.y = b;
        } else {
          this.v.z = b;
        }
      }
      return this;
    };

    return Quaternion;

  })();

  module.exports = {
    Vec2: Vec2,
    Vec3: Vec3,
    Vec4: Vec4,
    Matrix3: Matrix3,
    Matrix4: Matrix4,
    radToDeg: radToDeg,
    degToRad: degToRad,
    Quaternion: Quaternion,
    PI: PI
  };

}).call(this);

},{"./error":19}],6:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/
*/


(function() {
  var Colour, Geometry, Line, Matrix4, Quad, TriStrip, Triangle, TriangleMesh, Vec2, Vec3, Vec4, Vertex, type, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Colour = require('./colour').Colour;

  _ref = require('./math'), Matrix4 = _ref.Matrix4, Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Vec4 = _ref.Vec4;

  Geometry = (function() {

    function Geometry() {}

    Geometry.prototype._addToNode = function(node) {
      node.geometry = this;
      return this;
    };

    return Geometry;

  })();

  Vertex = (function() {

    function Vertex(p, c, n, t) {
      this.p = p;
      this.c = c;
      this.n = n;
      this.t = t;
      if (this.p == null) {
        this.p = new Vec3(0, 0, 0);
      }
    }

    Vertex.prototype.flatten = function() {
      var t;
      t = [];
      t.concat(this.p.flatten());
      t.concat(this.c.flatten());
      if (this.n) {
        t.concat(this.n.flatten());
      }
      if (this.t) {
        t.concat(this.t.flatten());
      }
      return t;
    };

    return Vertex;

  })();

  type = function(obj) {
    var classToType, myClass, name, _i, _len, _ref1;
    if (obj === void 0 || obj === null) {
      return String(obj);
    }
    classToType = new Object;
    _ref1 = "Boolean Number String Function Array Date";
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      name = _ref1[_i];
      RegExp.split(" ");
    }
    myClass = Object.prototype.toString.call(obj);
    if (myClass in classToType) {
      return classToType(myClass);
    }
    return 'object';
  };

  Triangle = (function(_super) {

    __extends(Triangle, _super);

    function Triangle(p0, p1, p2) {
      Triangle.__super__.constructor.call(this);
      if ((p0 == null) || (p1 == null) || (p2 == null)) {
        this.v = [new Vertex(new Vec3(-1, -1, 0)), new Vertex(new Vec3(1, -1, 0)), new Vertex(new Vec3(0, 1, 0))];
      } else {
        this.v = [p0, p1, p2];
      }
    }

    Triangle.prototype.flatten = function() {
      var t;
      t = [];
      t = t.concat(this.v[0].flatten());
      t = t.concat(this.v[1].flatten());
      t = t.concat(this.v[2].flatten());
      return t;
    };

    Triangle.prototype.computeNormals = function() {
      var l0, l1, n;
      l0 = Vec3.sub(this.v[1].v, this.v[0].v);
      l1 = Vec3.sub(this.v[2].v, this.v[1].v);
      n = l0.cross(l1);
      n.normalize();
      this.v[1].n = n;
      this.v[1].n = n;
      this.v[2].n = n;
      return this;
    };

    return Triangle;

  })(Geometry);

  Quad = (function(_super) {

    __extends(Quad, _super);

    function Quad(p0, p1, p2, p3) {
      Quad.__super__.constructor.call(this);
      if ((p0 == null) || (p1 == null) || (p2 == null) || (p3 == null)) {
        p0 = new Vertex(new Vec3(-1, -1, 0), new Colour.RGBA(1.0, 1.0, 1.0, 1.0), new Vec3(0, 0, 1), new Vec2(0, 0));
        p1 = new Vertex(new Vec3(-1, 1, 0), new Colour.RGBA(1.0, 1.0, 1.0, 1.0), new Vec3(0, 0, 1), new Vec2(0, 1));
        p2 = new Vertex(new Vec3(1, -1, 0), new Colour.RGBA(1.0, 1.0, 1.0, 1.0), new Vec3(0, 0, 1), new Vec2(1, 0));
        p3 = new Vertex(new Vec3(1, 1, 0), new Colour.RGBA(1.0, 1.0, 1.0, 1.0), new Vec3(0, 0, 1), new Vec2(1, 1));
      }
      this.v = [p0, p1, p2, p3];
    }

    Quad.prototype.computeNormals = function() {
      var l0, l1, n;
      l0 = Vec3.sub(this.v[1].v, this.v[0].v);
      l1 = Vec3.sub(this.v[2].v, this.v[1].v);
      n = l0.cross(l1);
      n.normalize();
      this.v[0].n = n;
      this.v[1].n = n;
      this.v[2].n = n;
      this.v[3].n = n;
      return this;
    };

    Quad.prototype.flatten = function() {
      var t;
      t = [];
      t = t.concat(this.v[0].flatten());
      t = t.concat(this.v[1].flatten());
      t = t.concat(this.v[2].flatten());
      t = t.concat(this.v[3].flatten());
      return t;
    };

    Quad.prototype._drawPrimitive = function() {
      if (CoffeeGL.Context != null) {
        return CoffeeGL.Context.gl.TRIANGLE_STRIP;
      }
    };

    return Quad;

  })(Geometry);

  TriStrip = (function() {

    function TriStrip() {}

    TriStrip.prototype._drawPrimitive = function() {
      if (CoffeeGL.Context != null) {
        return CoffeeGL.Context.gl.TRIANGLE_STRIP;
      }
    };

    return TriStrip;

  })();

  Line = (function(_super) {

    __extends(Line, _super);

    function Line(s, e) {
      this.s = s;
      this.e = e;
      Line.__super__.constructor.call(this);
    }

    return Line;

  })(Geometry);

  TriangleMesh = (function(_super) {

    __extends(TriangleMesh, _super);

    function TriangleMesh(indexed) {
      this.indexed = indexed;
      TriangleMesh.__super__.constructor.call(this);
      this.v = [];
      this.t = [];
      if ((this.indexed != null) === true) {
        this.indices = [];
      }
    }

    TriangleMesh.prototype.addTriangle = function(t) {
      var idx, p, ti, v, _i, _j, _len, _ref1;
      if (this.indices) {
        for (idx = _i = 0; _i <= 2; idx = ++_i) {
          p = this._findV(t.v[idx]);
          if (p === -1) {
            this.v.push(t.v[idx]);
            ti = this.v.length;
            ti -= 1;
            t.v[idx]._idx = ti;
            this.indices.push(ti);
          } else {
            this.indices.push(p);
          }
        }
      } else {
        _ref1 = t.v;
        for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
          v = _ref1[_j];
          this.v.push(v);
        }
      }
      this.t.push(t);
      return this;
    };

    TriangleMesh.prototype.addVertex = function(v) {
      this.v.push(v);
      return this;
    };

    TriangleMesh.prototype.addIndex = function(idx) {
      if (typeof indices !== "undefined" && indices !== null) {
        return indices.push(idx);
      }
    };

    /*
    addTriangleFromIndices : (indices) ->
      if @indices? 
        for v in indices
          if v >= @v.length
            console.log "CoffeeGL Warning - Adding indices past vertex range in TriangleMesh"
            return
          @indices.push v
      @
    
     addQuadFromIndices : (indices) ->
      if @indices? 
        for v in indices
          if v >= @v.length
            console.log "CoffeeGL Warning - Adding indices past vertex range in TriangleMesh"
            return
    
        @indices.push indices[0]
        @indices.push indices[1]
        @indices.push indices[2]
    
        @indices.push indices[0]
        @indices.push indices[2]
        @indices.push indices[3]
      @
    */


    TriangleMesh.prototype.addQuad = function(q) {
      var i, idx, p, ti, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2, _ref3, _ref4;
      if (this.indices) {
        _ref1 = [0, 1, 3];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          idx = _ref1[_i];
          p = this._findV(q.v[idx]);
          if (p === -1) {
            this.v.push(q.v[idx]);
            ti = this.v.length;
            ti -= 1;
            q.v[idx]._idx = ti;
            this.indices.push(ti);
          } else {
            this.indices.push(p);
          }
        }
        _ref2 = [2, 3, 1];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          idx = _ref2[_j];
          p = this._findV(q.v[idx]);
          if (p === -1) {
            this.v.push(q.v[idx]);
            ti = this.v.length;
            ti -= 1;
            q.v[idx]._idx = ti;
            this.indices.push(ti);
          } else {
            this.indices.push(p);
          }
        }
      } else {
        _ref3 = [0, 1, 3];
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          i = _ref3[_k];
          this.v.push(q.v[i]);
        }
        _ref4 = [2, 3, 1];
        for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
          i = _ref4[_l];
          this.v.push(q.v[i]);
        }
      }
      this.t.push(new Triangle(q.v[0], q.v[1], q.v[3]));
      this.t.push(new Triangle(q.v[2], q.v[3], q.v[1]));
      return this;
    };

    TriangleMesh.prototype._findV = function(vf) {
      var idx, _i, _ref1;
      if (vf._idx != null) {
        return vf._idx;
      }
      if (this.v.length > 0) {
        for (idx = _i = 0, _ref1 = this.v.length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; idx = 0 <= _ref1 ? ++_i : --_i) {
          if (this.v[idx] === vf) {
            return idx;
          }
        }
      }
      return -1;
    };

    TriangleMesh.prototype._drawPrimitive = function() {
      if (CoffeeGL.Context != null) {
        return CoffeeGL.Context.gl.TRIANGLES;
      }
    };

    return TriangleMesh;

  })(Geometry);

  module.exports = {
    Geometry: Geometry,
    Vertex: Vertex,
    Triangle: Triangle,
    Quad: Quad,
    TriangleMesh: TriangleMesh
  };

}).call(this);

},{"./colour":5,"./math":4}],7:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/
*/


(function() {
  var Camera, Geometry, Material, Matrix3, Matrix4, Node, PointLight, Texture, Vec3, Vec4, makeDrawableGL, util, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = require('./math'), Vec3 = _ref.Vec3, Vec4 = _ref.Vec4, Matrix3 = _ref.Matrix3, Matrix4 = _ref.Matrix4;

  makeDrawableGL = require('./webgl').makeDrawableGL;

  Camera = require('./camera').Camera;

  Material = require('./material').Material;

  Texture = require('./texture').Texture;

  PointLight = require('./Light').PointLight;

  Geometry = require('./primitives').Geometry;

  util = require('./util');

  Node = (function() {
    var _computeMatrix;

    function Node(geometry, material, textures, shader, pointLights) {
      this.geometry = geometry;
      this.material = material;
      this.textures = textures;
      this.shader = shader;
      this.pointLights = pointLights;
      this.matrix = new Matrix4();
      this._modelMatrix = new Matrix4();
      this._normalMatrix = new Matrix3();
      this.children = [];
      if (this.pointLights == null) {
        this.pointLights = [];
        this.pointLightsGlobal = [];
        this.numPointLights = 0;
        this.numPointLightsGlobal = 0;
      }
      if (this.textures == null) {
        this.textures = [];
      }
    }

    Node.prototype.add = function(p) {
      if (typeof p._addToNode === "function") {
        p._addToNode(this);
      }
      return this;
    };

    Node.prototype.remove = function(p) {
      if (typeof p._removeFromNode === "function") {
        p._removeFromNode(this);
      }
      return this;
    };

    Node.prototype._addToNode = function(node) {
      this.parent = node;
      node.children.push(this);
      return this;
    };

    Node.prototype.del = function(p) {
      var i;
      p.parent = void 0;
      if (__indexOf.call(this.children, p) >= 0) {
        i = this.children.indexOf(p);
        this.children.splice(i, 1);
      }
      return this;
    };

    _computeMatrix = function(m, p) {
      if (p.parent != null) {
        this._computeMatrix(m, p.parent);
      }
      m.mult(p.matrix);
      return m;
    };

    Node.prototype.draw = function() {
      return this._draw(this, new Matrix4());
    };

    Node.prototype._draw = function(node, m) {
      var child, light, newlight, nm, np, tex, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2, _ref3, _ref4;
      _ref1 = node.textures;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        tex = _ref1[_i];
        tex.bind();
      }
      node._modelMatrix.toIdentity();
      if (m != null) {
        node._modelMatrix.mult(m);
      }
      node._modelMatrix.mult(node.matrix);
      nm = node._modelMatrix.copy();
      node._normalMatrix = nm.invert().transpose().getMatrix3();
      if (node.pointLights != null) {
        node.pointLightsGlobal = [];
        if (node.parent != null) {
          node.pointLightsGlobal = node.pointLightsGlobal.concat(node.parent.pointLightsGlobal);
        }
        _ref2 = node.pointLights;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          light = _ref2[_j];
          newlight = util.clone(light);
          node._modelMatrix.multVec3(newlight.pos);
          node.pointLightsGlobal.push(newlight);
        }
        node.numPointLightsGlobal = node.pointLightsGlobal.length;
      }
      if ((node.camera == null) && (node.parent != null)) {
        np = node.parent;
        while (np != null) {
          if (np.camera != null) {
            node.camera = np.camera;
            break;
          }
          np = np.parent;
        }
      }
      if (node.geometry != null) {
        if (node.brewed != null) {
          if (!node.brewed) {
            node.brew();
          } else {
            node.drawGL();
          }
        } else {
          makeDrawableGL(node);
        }
      }
      _ref3 = node.children;
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        child = _ref3[_k];
        this._draw(child, node._modelMatrix);
      }
      _ref4 = node.textures;
      for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
        tex = _ref4[_l];
        tex.unbind();
      }
      return node;
    };

    return Node;

  })();

  module.exports = {
    Node: Node
  };

}).call(this);

},{"./math":4,"./webgl":15,"./camera":13,"./material":18,"./texture":12,"./Light":20,"./primitives":6,"./util":2}],8:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/

- Resources

* http://www.yuiblog.com/blog/2007/06/12/module-pattern/
* http://www.plexical.com/blog/2012/01/25/writing-coffeescript-for-browser-and-nod/
*/


(function() {
  var CoffeeGLWarning, Colour, JSONModel, Material, Matrix4, Node, Quad, Request, Texture, Triangle, TriangleMesh, Vec2, Vec3, Vec4, Vertex, _ref, _ref1,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./primitives'), Triangle = _ref.Triangle, Quad = _ref.Quad, Vertex = _ref.Vertex, TriangleMesh = _ref.TriangleMesh;

  Node = require('./node').Node;

  _ref1 = require('./math'), Vec2 = _ref1.Vec2, Vec3 = _ref1.Vec3, Vec4 = _ref1.Vec4, Matrix4 = _ref1.Matrix4;

  Material = require('./material').Material;

  Colour = require('./colour').Colour;

  Texture = require('./texture').Texture;

  Request = require('./request').Request;

  CoffeeGLWarning = require('./error').CoffeeGLWarning;

  JSONModel = (function(_super) {

    __extends(JSONModel, _super);

    JSONModel.prototype._bitset = function(value, position) {
      return value & (1 << position);
    };

    function JSONModel(json_data) {
      var closure, colourAmbient, colourDiffuse, colourSpecular, i, materials, n, specularCoef, t, url, _i, _ref2,
        _this = this;
      this._parse = function(json_data) {
        return JSONModel.prototype._parse.apply(_this, arguments);
      };
      JSONModel.__super__.constructor.call(this);
      materials = json_data["materials"];
      if (materials.length === 0) {
        this.add(new Node(new TriangleMesh(true)));
      } else {
        for (i = _i = 0, _ref2 = materials.length - 1; 0 <= _ref2 ? _i <= _ref2 : _i >= _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
          n = new Node();
          this.add(n);
          if (json_data["materials"][i]["DbgName"] === "default" || json_data["materials"][i]["DbgIndex"] === 1) {
            n.add(new Material());
          } else {
            colourAmbient = new Colour.RGB(json_data["materials"][i]["colorAmbient"][0], json_data["materials"][i]["colorAmbient"][1], json_data["materials"][i]["colorAmbient"][2]);
            if (colourAmbient == null) {
              colourAmbient = Colour.RGB.WHITE();
            }
            colourDiffuse = new Colour.RGB(json_data["materials"][i]["colorDiffuse"][0], json_data["materials"][i]["colorDiffuse"][1], json_data["materials"][i]["colorDiffuse"][2]);
            if (colourDiffuse == null) {
              colourDiffuse = Colour.RGB.WHITE();
            }
            colourSpecular = new Colour.RGB(json_data["materials"][i]["colorSpecular"][0], json_data["materials"][i]["colorSpecular"][1], json_data["materials"][i]["colorSpecular"][2]);
            if (colourSpecular == null) {
              colourSpecular = Colour.RGB.WHITE();
            }
            specularCoef = json_data["materials"][i]["specularCoef"];
            n.add(new Material(colourAmbient, colourDiffuse, colourSpecular, specularCoef));
          }
          n.geometry = new TriangleMesh(true);
          if ((json_data["materials"][i]["mapDiffuse"] != null) && (json_data._coffeegl_request_url != null)) {
            url = json_data._coffeegl_request_url.substring(0, json_data._coffeegl_request_url.lastIndexOf("/"));
            closure = (function(n) {
              var _n;
              _n = n;
              return function() {
                return _n.add(this);
              };
            })(n);
            t = new Texture(url + "/" + json_data["materials"][i]["mapDiffuse"], {}, closure);
          }
        }
      }
      this._parse(json_data);
    }

    JSONModel.prototype._parse = function(json_data) {
      var cidx, i, i0, i1, i2, i3, midx, nidx, node_idx, prim, type, type2, uvidx, vertices, vi0, vi1, vi2, vi3, vidx;
      node_idx = 0;
      vidx = 0;
      vertices = [];
      while (vidx < json_data["vertices"].length) {
        vertices.push(new Vertex(new Vec3(json_data["vertices"][vidx++], json_data["vertices"][vidx++], json_data["vertices"][vidx++])));
      }
      i = 0;
      while (i < json_data["faces"].length) {
        type = json_data["faces"][i++];
        prim;
        vi0;
        vi1;
        vi2;
        vi3;
        midx = {
          id: 0,
          type: -1
        };
        if (this._bitset(type, 0)) {
          vi0 = json_data["faces"][i++];
          vi1 = json_data["faces"][i++];
          vi2 = json_data["faces"][i++];
          vi3 = json_data["faces"][i++];
          prim = new Quad(vertices[vi0], vertices[vi1], vertices[vi2], vertices[vi3]);
        } else {
          vi0 = json_data["faces"][i++];
          vi1 = json_data["faces"][i++];
          vi2 = json_data["faces"][i++];
          prim = new Triangle(vertices[vi0], vertices[vi1], vertices[vi2]);
        }
        if (this._bitset(type, 1)) {
          midx.id = json_data["faces"][i++];
          type2 = type | 1;
          if (midx.type === -1) {
            midx.type = type2;
          } else {
            if (type2 !== midx.type) {
              CoffeeGLWarning("Different types within the same material");
            }
          }
        }
        if (this._bitset(type, 2)) {
          uvidx = json_data["faces"][i++];
        }
        if (this._bitset(type, 3)) {
          i0 = json_data["faces"][i++];
          i1 = json_data["faces"][i++];
          i2 = json_data["faces"][i++];
          if (prim instanceof Quad) {
            i3 = json_data["faces"][i++];
            vertices[vi3].t = new Vec2(json_data["uvs"][0][i3 * 2], json_data["uvs"][0][i3 * 2 + 1]);
          }
          vertices[vi0].t = new Vec2(json_data["uvs"][0][i0 * 2], json_data["uvs"][0][i0 * 2 + 1]);
          vertices[vi1].t = new Vec2(json_data["uvs"][0][i1 * 2], json_data["uvs"][0][i1 * 2 + 1]);
          vertices[vi2].t = new Vec2(json_data["uvs"][0][i2 * 2], json_data["uvs"][0][i2 * 2 + 1]);
        }
        if (this._bitset(type, 4)) {
          nidx = json_data["faces"][i++];
        }
        if (this._bitset(type, 5)) {
          i0 = json_data["faces"][i++];
          i1 = json_data["faces"][i++];
          i2 = json_data["faces"][i++];
          if (prim instanceof Quad) {
            i3 = json_data["faces"][i++];
            vertices[vi3].n = new Vec3(json_data["normals"][i3 * 3], json_data["normals"][i3 * 3 + 1], json_data["normals"][i3 * 3 + 2]);
          }
          vertices[vi0].n = new Vec3(json_data["normals"][i0 * 3], json_data["normals"][i0 * 3 + 1], json_data["normals"][i0 * 3 + 2]);
          vertices[vi1].n = new Vec3(json_data["normals"][i1 * 3], json_data["normals"][i1 * 3 + 1], json_data["normals"][i1 * 3 + 2]);
          vertices[vi2].n = new Vec3(json_data["normals"][i2 * 3], json_data["normals"][i2 * 3 + 1], json_data["normals"][i2 * 3 + 2]);
        }
        if (this._bitset(type, 6)) {
          cidx = json_data["faces"][i++];
        }
        if (this._bitset(type, 7)) {
          i0 = json_data["faces"][i++];
          i1 = json_data["faces"][i++];
          i2 = json_data["faces"][i++];
          if (prim instanceof Quad) {
            i3 = json_data["faces"][i++];
          }
        }
        if (prim instanceof Triangle) {
          this.children[midx.id].geometry.addTriangle(prim);
        } else {
          this.children[midx.id].geometry.addQuad(prim);
        }
      }
      return this;
    };

    return JSONModel;

  })(Node);

  module.exports = {
    JSONModel: JSONModel
  };

}).call(this);

},{"./primitives":6,"./node":7,"./math":4,"./material":18,"./colour":5,"./texture":12,"./request":10,"./error":19}],9:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*                    __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/

- TODO - can we inspect objects / nodes / vertices at bind time and add / remove the attributes
automatically? That way we wouldnt need basic and texture shaders

- TODO - Light information should be passed in as a texture on an un-used unit eventually
  - we dont have uniform buffers you see
*/


(function() {
  var CoffeeGLError, CoffeeGLLog, CoffeeGLWarning, Contract, Light, Matrix4, Shader, ShaderLibrary, Vec2, Vec3, Vec4, _ref, _ref1;

  _ref = require('./math'), Matrix4 = _ref.Matrix4, Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Vec4 = _ref.Vec4;

  Light = require('./light').Light;

  ShaderLibrary = require('./shader_library').ShaderLibrary;

  _ref1 = require('./error'), CoffeeGLError = _ref1.CoffeeGLError, CoffeeGLWarning = _ref1.CoffeeGLWarning, CoffeeGLLog = _ref1.CoffeeGLLog;

  Contract = (function() {

    function Contract(attributes, uniforms, textures) {
      this.attributes = attributes;
      this.uniforms = uniforms;
      this.textures = textures;
      if (this.attributes == null) {
        this.attributes = [];
      }
      if (this.uniforms == null) {
        this.uniforms = [];
      }
      if (this.textures == null) {
        this.textures = [];
      }
    }

    Contract.prototype.setUniformRole = function(uniform, role) {
      var u, _i, _len, _ref2;
      _ref2 = this.uniforms;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        u = _ref2[_i];
        if (u.name === uniform) {
          u.role = role;
        }
      }
      return this;
    };

    Contract.prototype.setAttributeRole = function(attribute, role) {
      var a, _i, _len, _ref2;
      _ref2 = this.attributes;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        a = _ref2[_i];
        if (a.name === attribute) {
          a.role = role;
        }
      }
      return this;
    };

    return Contract;

  })();

  Shader = (function() {

    function Shader(s, roles) {
      var gl, match, matches, type, _i, _j, _len, _len1;
      this._splitShader(s);
      if (this.sv == null) {
        CoffeeGLError("No Vertex Shader Provided");
        return;
      }
      if (this.sf == null) {
        CoffeeGLError("No Fragment Shader Provided");
        return;
      }
      if (CoffeeGL.Context == null) {
        CoffeeGLError("No Context for Shader Provided");
        return;
      }
      gl = CoffeeGL.Context.gl;
      matches = this.sv.match(/\{\{(ShaderLibrary\.[a-zA-Z]+)\}\}/g);
      if (matches != null) {
        for (_i = 0, _len = matches.length; _i < _len; _i++) {
          match = matches[_i];
          type = match.replace("}}", "").split(".")[1];
          if (ShaderLibrary[type] == null) {
            CoffeeGLError("Could not find " + type + "in Shader Library");
          } else {
            this.sv = this.sv.replace(match, ShaderLibrary[type].vertex);
          }
        }
      }
      matches = this.sf.match(/\{\{(ShaderLibrary\.[a-zA-Z]+)\}\}/g);
      if (matches != null) {
        for (_j = 0, _len1 = matches.length; _j < _len1; _j++) {
          match = matches[_j];
          type = match.replace("}}", "").split(".")[1];
          if (ShaderLibrary[type] == null) {
            CoffeeGLError("Could not find " + type + "in Shader Library");
          } else {
            this.sf = this.sf.replace(match, ShaderLibrary[type].fragment);
          }
        }
      }
      this.sv = this.sv.replace(/;(?! [a-zA-Z0-9])/g, ';\n');
      this.sv = this.sv.replace(/\{/g, '{\n');
      this.sv = this.sv.replace(/\}/g, '}\n');
      this.sf = this.sf.replace(/;(?! [a-zA-Z0-9])/g, ';\n');
      this.sf = this.sf.replace(/;(?! [a-zA-Z0-9])/g, ';\n');
      this.sf = this.sf.replace(/\{/g, '{\n');
      this.sf = this.sf.replace(/\}/g, '}\n');
      this.compile(roles);
    }

    Shader.prototype.compile = function(roles) {
      var attr, attrs, compilationLog, gl, idx, _i, _len;
      gl = CoffeeGL.Context.gl;
      this.vertexShader = gl.createShader(gl.VERTEX_SHADER);
      if (!this.vertexShader) {
        CoffeeGLError("No vertex shader object could be created");
      }
      this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      if (!this.fragmentShader) {
        CoffeeGLError("No Fragment shader object could be created");
      }
      gl.shaderSource(this.vertexShader, this.sv);
      gl.compileShader(this.vertexShader);
      if (!gl.getShaderParameter(this.vertexShader, gl.COMPILE_STATUS)) {
        compilationLog = gl.getShaderInfoLog(this.vertexShader);
        CoffeeGLLog('Shader compiler log: ' + compilationLog);
        CoffeeGLLog(this.sv);
        CoffeeGLError("Could not compile vertex shader");
      }
      gl.shaderSource(this.fragmentShader, this.sf);
      gl.compileShader(this.fragmentShader);
      if (!gl.getShaderParameter(this.fragmentShader, gl.COMPILE_STATUS)) {
        compilationLog = gl.getShaderInfoLog(this.fragmentShader);
        CoffeeGLLog("Shader compiler log: " + compilationLog);
        CoffeeGLLog(this.sf);
        CoffeeGLError("Could not compile fragment shader");
      }
      this.shaderProgram = gl.createProgram();
      attrs = this._parseShader("attribute");
      idx = 0;
      for (_i = 0, _len = attrs.length; _i < _len; _i++) {
        attr = attrs[_i];
        gl.bindAttribLocation(this.shaderProgram, idx, attr.name);
        idx++;
      }
      gl.attachShader(this.shaderProgram, this.vertexShader);
      gl.attachShader(this.shaderProgram, this.fragmentShader);
      gl.linkProgram(this.shaderProgram);
      this._makeContract(roles);
      return this;
    };

    Shader.prototype._splitShader = function(s) {
      var pf, pv;
      pv = s.indexOf("##>VERTEX");
      pf = s.indexOf("##>FRAGMENT");
      if (pv < pf) {
        this.sv = s.slice(pv + 9, pf);
        this.sf = s.slice(pf + 11);
      } else {
        this.sf = s.slice(pf + 11, pv);
        this.sv = s.slice(pv + 9);
      }
      return this;
    };

    Shader.prototype._getLocation = function(name) {
      var gl;
      gl = CoffeeGL.Context.gl;
      return gl.getUniformLocation(this.shaderProgram, name);
    };

    Shader.prototype.bind = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.useProgram(this.shaderProgram);
      CoffeeGL.Context.shader = this;
      return this;
    };

    Shader.prototype.unbind = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.useProgram(null);
      return this;
    };

    Shader.prototype.washUp = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.detachShader(this.shaderProgram, this.vertexShader);
      gl.detachShader(this.shaderProgram, this.fragmentShader);
      gl.deleteProgram(this.shaderProgram);
      gl.deleteShader(this.vertexShader);
      gl.deleteShader(this.fragmentShader);
      return this;
    };

    Shader.prototype._makeContract = function(user_roles) {
      var key, role, roles;
      this.contract = new Contract(this._getAttributes(), this._getUniforms(), this._getTextures());
      roles = {};
      roles.uModelMatrix = "_modelMatrix";
      roles.uProjectionMatrix = "camera/p";
      roles.uCameraMatrix = "camera/m";
      roles.uCameraInverseMatrix = "camera/i";
      roles.uNormalMatrix = "_normalMatrix";
      roles.uMaterialAmbientColor = "material/ambient";
      roles.uMaterialDiffuseColor = "material/diffuse";
      roles.uMaterialSpecularColor = "material/specular";
      roles.uMaterialShininess = "material/shine";
      roles.uMaterialEmissiveColor = "material/emissive";
      roles.uNumLights = "numPointLightsGlobal";
      roles.uPointLightPos = "pointlight/pos";
      roles.uPointLightDiffuse = "pointlight/colour";
      roles.uPointLightSpecular = "pointlight/specular";
      roles.uPointLightAttenuation = "pointlight/attenuation";
      roles.aVertexPosition = "vertexPositionBuffer";
      roles.aVertexTexCoord = "vertexTextureBuffer";
      roles.aVertexNormal = "vertexNormalBuffer";
      roles.aVertexColour = "vertexColourBuffer";
      roles.aVertexTangent = "vertexTangentBuffer";
      if (user_roles != null) {
        for (key in user_roles) {
          roles[key] = user_roles[key];
        }
      }
      for (role in roles) {
        this.contract.setUniformRole(role, roles[role]);
        this.contract.setAttributeRole(role, roles[role]);
      }
      return this;
    };

    Shader.prototype._posForAttrRole = function(role) {
      var a, _i, _len, _ref2;
      _ref2 = this.contract.attributes;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        a = _ref2[_i];
        if (a.role === role) {
          return a.pos;
        }
      }
      return -1;
    };

    Shader.prototype._getAttributes = function() {
      var a, d, p, _i, _len;
      d = this._parseShader("attribute");
      for (_i = 0, _len = d.length; _i < _len; _i++) {
        a = d[_i];
        p = this.getAttribLocation(a.name);
        if ((p != null) && p !== -1) {
          a.pos = p;
        }
      }
      return d;
    };

    Shader.prototype._getUniforms = function() {
      var a, d, p, _i, _len;
      d = this._parseShader("uniform");
      for (_i = 0, _len = d.length; _i < _len; _i++) {
        a = d[_i];
        p = this._getLocation(a.name);
        if ((p != null) && p !== -1) {
          a.pos = p;
        }
      }
      return d;
    };

    Shader.prototype._getTextures = function() {
      var a, d, p, x, _i, _len;
      d = this._parseShader("uniform");
      x = [];
      for (_i = 0, _len = d.length; _i < _len; _i++) {
        a = d[_i];
        if (a.type === "sampler2D") {
          p = this._getLocation(a.name);
          if ((p != null) && p !== -1) {
            a.pos = p;
            x.push(a);
          }
        }
      }
      return x;
    };

    Shader.prototype._parseShader = function(token) {
      var attr, data, finals, l, lines, matches, re, t, tokens, _i, _j, _len, _len1;
      data = [];
      lines = this.sv.split(";").concat(this.sf.split(";"));
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        l = lines[_i];
        re = RegExp("\\b" + token + "\\b");
        if (l.match(re) != null) {
          tokens = l.split(" ");
          finals = [];
          for (_j = 0, _len1 = tokens.length; _j < _len1; _j++) {
            t = tokens[_j];
            t = t.replace(/\n/, "");
            t = t.replace(/\s/, "");
            if (t.length !== 0) {
              finals.push(t);
            }
          }
          finals.push(1);
          matches = finals[2].match(/\[([0-9]+)\]/);
          if (matches != null) {
            finals[3] = matches[1];
          }
          finals[2] = finals[2].match(/([a-zA-Z]+)/g)[0];
          if (finals.length === 4) {
            attr = {};
            attr.name = finals[2];
            attr.type = finals[1];
            attr.role = attr.name;
            attr.pos = -1;
            attr.size = finals[3];
            data.push(attr);
          }
        }
      }
      return data;
    };

    Shader.prototype.setUniform3f = function(name, a, b, c) {
      var gl;
      if ((a == null) || (b == null) || (c == null)) {
        CoffeeGLWarning("Not enough parameters to setUniform3f");
      }
      gl = CoffeeGL.Context.gl;
      gl.uniform3f(this._getLocation(name), a, b, c);
      return this;
    };

    Shader.prototype.setUniform3v = function(name, v) {
      var a, gl;
      gl = CoffeeGL.Context.gl;
      a = v.flatten();
      gl.uniform3f(this._getLocation(name), a[0], a[1], a[2]);
      return this;
    };

    Shader.prototype.setUniform4f = function(name, a, b, c, d) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniform4f(this._getLocation(name), a, b, c, d);
      return this;
    };

    Shader.prototype.setUniform4v = function(name, v) {
      var a, gl;
      gl = CoffeeGL.Context.gl;
      a = v.flatten();
      gl.uniform4f(this._getLocation(name), a[0], a[1], a[2], a[3]);
      return this;
    };

    Shader.prototype.setUniform1f = function(name, a) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniform1f(this._getLocation(name), a);
      return this;
    };

    Shader.prototype.setUniform1i = function(name, a) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniform1i(this._getLocation(name), a);
      return this;
    };

    Shader.prototype.setUniform1fv = function(name, a) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniform1fv(this._getLocation(name), a);
      return this;
    };

    Shader.prototype.setUniform2fv = function(name, a) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniform2fv(this._getLocation(name), a);
      return this;
    };

    Shader.prototype.setUniform2v = function(name, v) {
      var a, gl;
      gl = CoffeeGL.Context.gl;
      a = v.flatten();
      gl.uniform3f(this._getLocation(name), a[0], a[1]);
      return this;
    };

    Shader.prototype.setUniform3fv = function(name, a) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniform3fv(this._getLocation(name), a);
      return this;
    };

    Shader.prototype.setUniform4fv = function(name, a) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniform4fv(this._getLocation(name), a);
      return this;
    };

    Shader.prototype.setMatrix4f = function(name, m) {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.uniformMatrix4fv(this._getLocation(name), false, m.a);
      return this;
    };

    Shader.prototype.enableAttribArray = function(name) {
      var gl, position;
      gl = CoffeeGL.Context.gl;
      position = gl.getAttribLocation(this.shaderProgram, name);
      gl.enableVertexAttribArray(position);
      return this;
    };

    Shader.prototype.getAttribLocation = function(name) {
      var gl;
      gl = CoffeeGL.Context.gl;
      return gl.getAttribLocation(this.shaderProgram, name);
    };

    return Shader;

  })();

  module.exports = {
    Shader: Shader
  };

}).call(this);

},{"./math":4,"./light":17,"./shader_library":21,"./error":19}],10:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*                    __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/

- Resources

* http://coffeescriptcookbook.com/chapters/ajax/ajax_request_without_jquery

TODO - Need to check if its binary, json or other here, properly!
*/


(function() {
  var CoffeeGL, Request;

  CoffeeGL = require('./coffeegl').CoffeeGL;

  Request = (function() {

    function Request(url) {
      this.url = url;
    }

    Request.prototype.get = function(callback) {
      var _this = this;
      this.req = new XMLHttpRequest();
      this.req.onreadystatechange = function() {
        var data, l;
        if (_this.req.readyState === 4) {
          if (_this.req.status === 200 || _this.req.status === 304) {
            l = _this.url.length - 1;
            if (_this.url.indexOf("xml", l - 3) >= 0 || _this.url.indexOf("js", l - 2) >= 0 || _this.url.indexOf("json", l - 2) >= 0) {
              data = eval('(' + _this.req.responseText + ')');
              data._coffeegl_request_url = _this.url;
              callback(data);
            } else {
              callback(_this.req.responseText);
            }
          }
        }
        return _this;
      };
      this.req.open('GET', this.url);
      this.req.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
      this.req.send(null);
      return this;
    };

    return Request;

  })();

  module.exports = {
    Request: Request
  };

}).call(this);

},{"./coffeegl":1}],11:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*                    __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/
*/


(function() {
  var CoffeeGLError, Colour, Fbo;

  CoffeeGLError = require('./error').CoffeeGLError;

  Colour = require('./colour').Colour;

  Fbo = (function() {

    function Fbo(width, height, channels, datatype) {
      var gl;
      this.width = width;
      this.height = height;
      this.channels = channels;
      this.datatype = datatype;
      gl = CoffeeGL.Context.gl;
      if (!((this.width != null) && (this.height != null))) {
        this.width = CoffeeGL.Context.width;
        this.height = CoffeeGL.Context.height;
      }
      if (this.channels == null) {
        this.channels = gl.RGBA;
      }
      if (this.datatype == null) {
        this.datatype = gl.UNSIGNED_BYTE;
      }
      this.framebuffer = gl.createFramebuffer();
      console.log(this.width, this.height);
      this._build();
    }

    Fbo.prototype.resize = function(w, h) {
      if (w instanceof Vec2) {
        this.width = w.x;
        this.height = w.y;
      } else if ((w != null) && (h != null)) {
        this.width = w;
        this.height = h;
      } else {
        return this;
      }
      this._build();
      return this;
    };

    Fbo.prototype._build = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      if (this.texture == null) {
        this.texture = gl.createTexture();
      }
      gl.bindTexture(gl.TEXTURE_2D, this.texture);
      gl.texImage2D(gl.TEXTURE_2D, 0, this.channels, this.width, this.height, 0, this.channels, this.datatype, null);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this.renderbuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture, 0);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, this.width, this.height);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.renderbuffer);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
        return CoffeeGLError("Failed to Create Framebuffer!");
      }
    };

    Fbo.prototype.bind = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      gl.bindRenderbuffer(gl.RENDERBUFFER, this.renderbuffer);
      return gl.viewport(0, 0, this.width, this.height);
    };

    Fbo.prototype.unbind = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      return gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    };

    Fbo.prototype.clear = function(colour) {
      var gl;
      gl = CoffeeGL.Context.gl;
      if (colour == null) {
        gl.clearColor(0.0, 0.0, 0.0, 0.0);
      } else {
        if (colour instanceof Colour.RGBA) {
          gl.clearColor(colour.r, colour.g, colour.b, colour.a);
        } else if (colour instanceof Colour.RGB) {
          gl.clearColor(colour.r, colour.g, colour.b, 0.0);
        }
      }
      return gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    };

    Fbo.prototype.washUp = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.deleteFramebuffer(this.framebuffer);
      gl.deleteRenderbuffer(this.renderbuffer);
      return gl.deleteTexture(this.texture);
    };

    return Fbo;

  })();

  module.exports = {
    Fbo: Fbo
  };

}).call(this);

},{"./error":19,"./colour":5}],12:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/

TODO - Probably pass in data and have a convinence method that calls a request?
  - handling no RGBA textures like JPGS?

https://developer.mozilla.org/en-US/docs/WebGL/Animating_textures_in_WebGL
*/


(function() {
  var Request, Texture, TextureCube;

  Request = require('./request').Request;

  Texture = (function() {

    function Texture(url, params, callback) {
      var gl, r,
        _this = this;
      this.url = url;
      this.params = params;
      this.callback = callback;
      this.loaded = false;
      if ((this.url == null) || (CoffeeGL.Context.gl == null)) {
        console.log("Error - no context or url provided for texture");
      }
      gl = CoffeeGL.Context.gl;
      r = new Request(this.url);
      r.get(function() {
        _this.texImage = new Image();
        _this.texture = gl.createTexture();
        _this.texImage.src = _this.url;
        return _this.texImage.onload = function() {
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.bindTexture(gl.TEXTURE_2D, _this.texture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, _this.texImage);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.bindTexture(gl.TEXTURE_2D, null);
          _this.loaded = true;
          return _this.callback();
        };
      });
    }

    Texture.prototype.bind = function(unit) {
      var gl;
      gl = CoffeeGL.Context.gl;
      if ((gl != null) && this.loaded) {
        if (unit != null) {
          return gl.activeTexture(gl.TEXTURE + unit);
        } else {
          gl.activeTexture(gl.TEXTURE0);
          return gl.bindTexture(gl.TEXTURE_2D, this.texture);
        }
      }
    };

    Texture.prototype.unbind = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      if (this.loaded && (gl != null)) {
        return gl.bindTexture(gl.TEXTURE_2D, null);
      }
    };

    Texture.prototype._addToNode = function(node) {
      node.textures.push(this);
      return this;
    };

    Texture.prototype._removeFromNode = function(node) {
      node.textures.splice(node.textures.indexOf(this));
      return this;
    };

    Texture.prototype.washUp = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      gl.deleteTexture(this.texure);
      return this;
    };

    return Texture;

  })();

  TextureCube = (function() {

    function TextureCube(paths) {
      var gl, i, loadedTextures, _i,
        _this = this;
      this.paths = paths;
      this.loaded = false;
      if ((this.paths == null) || (CoffeeGL.Context == null)) {
        console.log("Error - no context or urls provided for texture");
      }
      gl = CoffeeGL.Context.gl;
      this.texture = gl.createTexture();
      this.texImages = [];
      loadedTextures = 0;
      for (i = _i = 0; _i <= 5; i = ++_i) {
        this.texImages[i] = new Image();
        this.texImages[i].cubeID = i;
        this.texImages[i].onload = function() {
          var j, _j;
          loadedTextures++;
          if (loadedTextures === 6) {
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, _this.texture);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            for (j = _j = 0; _j <= 5; j = ++_j) {
              gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + j, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, _this.texImages[j]);
            }
            gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
            return _this.loaded = true;
          }
        };
        this.texImages[i].src = this.paths[i];
      }
    }

    TextureCube.prototype.bind = function(unit) {
      var gl;
      gl = CoffeeGL.Context.gl;
      if (this.loaded) {
        if (unit != null) {
          gl.activeTexture(gl.TEXTURE + unit);
        } else {
          gl.activeTexture(gl.TEXTURE0);
          gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.texture);
        }
        return CoffeeGL.Context.shader.setUniform1i("uSampler", 0);
      }
    };

    TextureCube.prototype.unbind = function() {
      var gl;
      gl = CoffeeGL.Context.gl;
      return gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
    };

    TextureCube.prototype._addToNode = function(node) {
      return node.textures.push(this);
    };

    return TextureCube;

  })();

  module.exports = {
    Texture: Texture,
    TextureCube: TextureCube
  };

}).call(this);

},{"./request":10}],13:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/
*/


(function() {
  var Camera, Matrix4, MousePerspCamera, OrthoCamera, PerspCamera, Primitive, Quaternion, Vec3, Vec4, degToRad, makeMouseListener, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./math'), Vec3 = _ref.Vec3, Vec4 = _ref.Vec4, Matrix4 = _ref.Matrix4, Quaternion = _ref.Quaternion, degToRad = _ref.degToRad;

  Primitive = require('./primitives').Primitive;

  makeMouseListener = require('./signal').makeMouseListener;

  Camera = (function() {

    function Camera(pos, look, up) {
      this.pos = pos;
      this.look = look;
      this.up = up;
      if (this.pos == null) {
        this.pos = new Vec3(0, 0, 5);
      }
      if (this.look == null) {
        this.look = new Vec3(0, 0, 0);
      }
      if (this.up == null) {
        this.up = new Vec3(0, 1, 0);
      }
      this.m = new Matrix4();
      this.p = new Matrix4();
      this.i = new Matrix4();
    }

    Camera.prototype.update = function() {
      this.m.lookAt(this.pos, this.look, this.up);
      this.i = Matrix4.invert(this.m);
      return this;
    };

    Camera.prototype._addToNode = function(node) {
      node.camera = this;
      return this;
    };

    return Camera;

  })();

  OrthoCamera = (function(_super) {

    __extends(OrthoCamera, _super);

    function OrthoCamera(pos, look, up, near, far) {
      this.pos = pos;
      this.look = look;
      this.up = up;
      this.near = near;
      this.far = far;
      OrthoCamera.__super__.constructor.call(this, this.pos, this.look, this.up);
      if (this.near == null) {
        this.near = 0.1;
      }
      if (this.far == null) {
        this.far = 10.0;
      }
    }

    OrthoCamera.prototype.update = function(w, h) {
      OrthoCamera.__super__.update.call(this);
      this.p.makeOrtho(0, w, 0, h, this.near, this.far);
      return this;
    };

    return OrthoCamera;

  })(Camera);

  PerspCamera = (function(_super) {

    __extends(PerspCamera, _super);

    function PerspCamera(pos, look, up, angle, near, far) {
      this.pos = pos;
      this.look = look;
      this.up = up;
      this.angle = angle;
      this.near = near;
      this.far = far;
      PerspCamera.__super__.constructor.call(this, this.pos, this.look, this.up);
      if (this.angle == null) {
        this.angle = 50.0;
      }
      if (this.near == null) {
        this.near = 0.1;
      }
      if (this.far == null) {
        this.far = 100.0;
      }
    }

    PerspCamera.prototype.update = function(w, h) {
      if (w == null) {
        w = CoffeeGL.Context.width;
        h = CoffeeGL.Context.height;
      }
      PerspCamera.__super__.update.call(this);
      this.p.makePerspective(this.angle, w / h, this.near, this.far);
      return this;
    };

    return PerspCamera;

  })(Camera);

  MousePerspCamera = (function(_super) {

    __extends(MousePerspCamera, _super);

    function MousePerspCamera(pos, look, up, angle, near, far, sense) {
      this.pos = pos;
      this.look = look;
      this.up = up;
      this.angle = angle;
      this.near = near;
      this.far = far;
      this.sense = sense;
      MousePerspCamera.__super__.constructor.call(this, this.pos, this.look, this.up, this.angle, this.near, this.far);
      CoffeeGL.Context.mouseMove.add(this.onMouseMove, this);
      CoffeeGL.Context.mouseDown.add(this.onMouseDown, this);
      CoffeeGL.Context.mouseUp.add(this.onMouseUp, this);
      CoffeeGL.Context.mouseWheel.add(this.onMouseWheel, this);
      if (this.sense == null) {
        this.sense = 0.3;
      }
      this._mouseDown = false;
      this.px = 0;
      this.py = 0;
      this.dx = 0;
      this.dy = 0;
      this.q = new Quaternion();
      this.m.lookAt(this.pos, this.look, this.up);
      this.i = Matrix4.invert(this.m);
      this;
    }

    MousePerspCamera.prototype.onMouseMove = function(event) {
      var dir, q2, x, y;
      if (this._mouseDown) {
        x = event.mouseX;
        y = event.mouseY;
        this.dx = x - this.px;
        this.px = x;
        this.dy = y - this.py;
        this.py = y;
        this.q.fromAxisAngle(new Vec3(0, 1, 0), degToRad(-this.dx * this.sense));
        dir = Vec3.sub(this.look, this.pos);
        dir.normalize();
        q2 = new Quaternion();
        q2.fromAxisAngle(Vec3.cross(dir, this.up), degToRad(this.dy * this.sense));
        q2.mult(this.q);
        q2.transVec3(this.pos);
        q2.transVec3(this.up);
      }
      this.m.lookAt(this.pos, this.look, this.up);
      this.i = Matrix4.invert(this.m);
      return this;
    };

    MousePerspCamera.prototype.onMouseDown = function(event) {
      var x, y;
      this._mouseDown = true;
      x = event.mouseX;
      y = event.mouseY;
      this.px = x;
      this.py = y;
      this.dx = 0;
      return this.dy = 0;
    };

    MousePerspCamera.prototype.onMouseUp = function(event) {
      return this._mouseDown = false;
    };

    MousePerspCamera.prototype.onMouseWheel = function(event) {
      var dir;
      dir = Vec3.sub(this.look, this.pos);
      if (dir.length() > event.wheelDelta * 0.01 * this.sense * 2) {
        dir.normalize();
        dir.multScalar(event.wheelDelta * 0.01 * this.sense);
        this.pos.add(dir);
      }
      return this;
    };

    MousePerspCamera.prototype.update = function(w, h) {
      if (w == null) {
        w = CoffeeGL.Context.width;
        h = CoffeeGL.Context.height;
      }
      this.p.makePerspective(this.angle, w / h, this.near, this.far);
      this.i = Matrix4.invert(this.m);
      return this;
    };

    MousePerspCamera.prototype.onMouseOut = function(event) {
      this.px = 0;
      this.py = 0;
      this.dx = 0;
      return this.dy = 0;
    };

    MousePerspCamera.prototype.onMouseOver = function(event) {
      var _ref1;
      if (this.px === 0 && this.py === 0) {
        return _ref1 = [event.mouseX, event.mouseY], this.px = _ref1[0], this.py = _ref1[1], _ref1;
      }
    };

    return MousePerspCamera;

  })(PerspCamera);

  module.exports = {
    Camera: Camera,
    OrthoCamera: OrthoCamera,
    PerspCamera: PerspCamera,
    MousePerspCamera: MousePerspCamera
  };

}).call(this);

},{"./math":4,"./primitives":6,"./signal":16}],14:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/
*/


(function() {
  var CoffeeGL, Colour, Cube, CurveCubic, Node, PI, Quad, Sphere, Triangle, Vec2, Vec3, Vertex, nodeSphere, _ref, _ref1;

  CoffeeGL = require('./coffeegl').CoffeeGL;

  Node = require('./node').Node;

  Colour = require('./colour').Colour;

  _ref = require('./math'), Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, PI = _ref.PI;

  _ref1 = require('./primitives'), Vertex = _ref1.Vertex, Triangle = _ref1.Triangle, Quad = _ref1.Quad;

  Cube = (function() {

    function Cube(w, h, d) {
      this.w = w;
      this.h = h;
      this.d = d;
    }

    Cube;

    return Cube;

  })();

  Sphere = (function() {

    function Sphere(radius, segments, center) {
      var c, e, i, j, p, t, theta1, theta2, theta3, v, _i, _j, _ref2, _ref3;
      this.radius = radius;
      this.segments = segments;
      this.center = center;
      this.v = [];
      if (this.center == null) {
        this.center = new Vec3(0, 0, 0);
      }
      if (this.segments != null) {
        if (this.segments < 0) {
          this.segments = 10;
        }
      } else {
        this.segments = 10;
      }
      for (j = _i = 0, _ref2 = this.segments / 2; 0 <= _ref2 ? _i <= _ref2 : _i >= _ref2; j = 0 <= _ref2 ? ++_i : --_i) {
        theta1 = j * 2 * PI / this.segments - (PI / 2);
        theta2 = (j + 1) * 2 * PI / this.segments - (PI / 2);
        for (i = _j = 0, _ref3 = segments + 1; 0 <= _ref3 ? _j <= _ref3 : _j >= _ref3; i = 0 <= _ref3 ? ++_j : --_j) {
          e = new Vec3();
          theta3 = i * 2 * PI / this.segments;
          e.x = Math.cos(theta1) * Math.cos(theta3);
          e.y = Math.sin(theta1);
          e.z = Math.cos(theta1) * Math.sin(theta3);
          p = Vec3.multScalar(e, radius).add(this.center);
          c = new Colour.RGBA(1.0, 1.0, 1.0, 1.0);
          t = new Vec2(0.999 - i / this.segments, 0.999 - 2 * j / this.segments);
          v = new Vertex(p, c, e, t);
          this.v.push(v);
          e = new Vec3();
          e.x = Math.cos(theta2) * Math.cos(theta3);
          e.y = Math.sin(theta2);
          e.z = Math.cos(theta2) * Math.sin(theta3);
          p = Vec3.multScalar(e, radius).add(this.center);
          t = new Vec2(0.999 - i / this.segments, 0.999 - 2 * (j + 1) / this.segments);
          v = new Vertex(p, c, e, t);
          this.v.push(v);
        }
      }
    }

    Sphere.prototype._drawPrimitive = function() {
      if (typeof GL !== "undefined" && GL !== null) {
        return GL.TRIANGLE_STRIP;
      }
    };

    return Sphere;

  })();

  nodeSphere = function(radius, segments) {
    return new Node(new Sphere(radius, segments));
  };

  CurveCubic = (function() {

    function CurveCubic(v0, v1, v2, v3) {
      this.v0 = v0;
      this.v1 = v1;
      this.v2 = v2;
      this.v3 = v3;
    }

    CurveCubic.prototype._B1 = function(t) {
      return t * t * t;
    };

    CurveCubic.prototype._B2 = function(t) {
      return 3 * t * t * (1 - t);
    };

    CurveCubic.prototype._B3 = function(t) {
      return 3 * t * (1 - t) * (1 - t);
    };

    CurveCubic.prototype._B4 = function(t) {
      return (1 - t) * (1 - t) * (1 - t);
    };

    CurveCubic.prototype.pointOnCurve = function(val) {
      return new Vector3(v0.x * this._B1(val) + v1.x * this._B2(val) + v2.x * this._B3(val) + v3.x * this._B4(val), v0.y * this._B1(val) + v1.y * this._B2(val) + v2.y * this._B3(val) + v3.y * this._B4(val), v0.z * this._B1(val) + v1.z * this._B2(val) + v2.z * this._B3(val) + v3.z * this._B4(val));
    };

    return CurveCubic;

  })();

  module.exports = {
    Cube: Cube,
    Sphere: Sphere,
    CurveCubic: CurveCubic,
    nodeSphere: nodeSphere
  };

}).call(this);

},{"./coffeegl":1,"./node":7,"./colour":5,"./math":4,"./primitives":6}],15:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/
*/


(function() {
  var CoffeeGLWarning, CoffeeGLWarningOnce, Colour, Matrix4, Quad, Triangle, TriangleMesh, Vec2, Vec3, Vertex, WebGLQuad, WebGLTriangle, WebGLTriangleMesh, createArrayBuffer, createElementBuffer, deleteBuffer, makeDrawableGL, util, _attribTypeCheckSet, _drawGL, _matchWithShader, _ref, _ref1, _ref2, _splitRole, _typeCheckSet, _washup;

  _ref = require('./math'), Matrix4 = _ref.Matrix4, Vec3 = _ref.Vec3, Vec2 = _ref.Vec2;

  Colour = require('./colour').Colour;

  _ref1 = require('./primitives'), Vertex = _ref1.Vertex, Triangle = _ref1.Triangle, Quad = _ref1.Quad, TriangleMesh = _ref1.TriangleMesh;

  _ref2 = require('./error'), CoffeeGLWarning = _ref2.CoffeeGLWarning, CoffeeGLWarningOnce = _ref2.CoffeeGLWarningOnce;

  util = require("./util");

  createArrayBuffer = function(data, type, size) {
    var buffer, gl;
    gl = CoffeeGL.Context.gl;
    buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, type);
    buffer.itemSize = size;
    buffer.numItems = data.length / size;
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return buffer;
  };

  createElementBuffer = function(data, type, size) {
    var buffer, gl;
    gl = CoffeeGL.Context.gl;
    buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, type);
    buffer.itemSize = size;
    buffer.numItems = data.length;
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    return buffer;
  };

  deleteBuffer = function(buffer) {
    var gl;
    gl = CoffeeGL.Context.gl;
    gl.deleteBuffer(buffer);
    return this;
  };

  _attribTypeCheckSet = function(a, v) {
    var gl;
    gl = CoffeeGL.Context.gl;
    if (a.pos === -1) {
      CoffeeGLWarningOnce("Trying to set an attribute " + a.name + " that isnt used in the bound shader");
      return;
    }
    gl.enableVertexAttribArray(a.pos);
    gl.bindBuffer(gl.ARRAY_BUFFER, v[a.role]);
    if (a.type === "int") {
      gl.vertexAttribPointer(a.pos, 1, gl.INT, false, 0, 0);
    } else if (a.type === "float") {
      gl.vertexAttribPointer(a.pos, 1, gl.FLOAT, false, 0, 0);
    } else if (a.type === "vec2") {
      gl.vertexAttribPointer(a.pos, 2, gl.FLOAT, false, 0, 0);
    } else if (a.type === "vec3") {
      gl.vertexAttribPointer(a.pos, 3, gl.FLOAT, false, 0, 0);
    } else if (a.type === "vec4") {
      gl.vertexAttribPointer(a.pos, 4, gl.FLOAT, false, 0, 0);
    }
    return this;
  };

  _typeCheckSet = function(u, v, tag) {
    var gl, role;
    if (u.pos === -1) {
      CoffeeGLWarningOnce("Trying to set the uniform " + u.name + " that isnt used in the bound shader");
      return;
    }
    role = u.role;
    if (tag != null) {
      role = _splitRole(tag, u.role);
    }
    gl = CoffeeGL.Context.gl;
    if (u.size === 1) {
      if (u.type === "float") {
        gl.uniform1f(u.pos, v[role]);
      } else if (u.type === "int") {
        gl.uniform1i(u.pos, v[role]);
      } else if (u.type === "vec2") {
        gl.uniform2f(u.pos, v[role].x, v[role].y);
      } else if (u.type === "vec3") {
        if (v[role].x != null) {
          gl.uniform3f(u.pos, v[role].x, v[role].y, v[role].z);
        } else {
          gl.uniform3f(u.pos, v[role].r, v[role].g, v[role].b);
        }
      } else if (u.type === "vec4") {
        if (v[role].x != null) {
          gl.uniform4f(u.pos, v[role].x, v[role].y, v[role].z, v[role].w);
        } else {
          gl.uniform4f(u.pos, v[role].r, v[role].g, v[role].b, v[role].a);
        }
      } else if (u.type === "mat4") {
        gl.uniformMatrix4fv(u.pos, false, v[role].a);
      } else if (u.type === "mat3") {
        gl.uniformMatrix3fv(u.pos, false, v[role].a);
      } else if (u.type === "sampler2D") {
        gl.uniform1u(u.pos, v[role]);
      }
    } else {
      if (u.type === "float") {
        gl.uniform1fv(u.pos, new Float32Array(v[role]));
      } else if (u.type === "int") {
        gl.uniform1iv(u.pos, new Int32Array(v[role]));
      } else if (u.type === "vec2") {
        gl.uniform2fv(u.pos, new Float32Array(v[role]));
      } else if (u.type === "vec3") {
        gl.uniform3fv(u.pos, new Float32Array(v[role]));
      } else if (u.type === "vec4") {
        gl.uniform4fv(u.pos, new Float32Array(v[role]));
      }
    }
    return this;
  };

  _splitRole = function(tag, role) {
    if (role.indexOf(tag) !== -1) {
      return role.split("/")[1];
    }
    return role;
  };

  _matchWithShader = function(obj) {
    var a, attenuations, colours, contract, light, pointlights, positions, shader, speculars, t, u, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p, _ref10, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    if (CoffeeGL.Context.shader == null) {
      console.log("CoffeeGL Error - Not Shader bound when calling _matchWithShader");
      return obj;
    }
    if (CoffeeGL.Context.shader.contract == null) {
      console.log("CoffeeGL Error - Not Shader contract when calling _matchWithShader");
      return obj;
    }
    contract = CoffeeGL.Context.shader.contract;
    shader = CoffeeGL.Context.shader;
    _ref3 = contract.uniforms;
    for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
      u = _ref3[_i];
      if (obj[u.role] != null) {
        _typeCheckSet(u, obj);
      }
    }
    if (obj.camera != null) {
      _ref4 = contract.uniforms;
      for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
        u = _ref4[_j];
        if (obj.camera[_splitRole("camera", u.role)] != null) {
          _typeCheckSet(u, obj.camera, "camera");
        }
      }
    }
    if (obj.material != null) {
      _ref5 = contract.uniforms;
      for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
        u = _ref5[_k];
        if (obj.material[_splitRole("material", u.role)] != null) {
          _typeCheckSet(u, obj.material, "material");
        }
      }
    }
    if (obj.pointLightsGlobal.length > 0) {
      positions = [];
      colours = [];
      speculars = [];
      attenuations = [];
      _ref6 = obj.pointLightsGlobal;
      for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
        light = _ref6[_l];
        positions = positions.concat(light.pos.flatten());
        colours = colours.concat(light.colour.flatten());
        speculars = speculars.concat(light.specular.flatten());
        attenuations.push(light.attenuation);
      }
      positions = new Float32Array(positions);
      colours = new Float32Array(colours);
      speculars = new Float32Array(speculars);
      attenuations = new Float32Array(attenuations);
      pointlights = {
        pos: positions,
        colour: colours,
        specular: speculars,
        attenuations: attenuations
      };
      _ref7 = contract.uniforms;
      for (_m = 0, _len4 = _ref7.length; _m < _len4; _m++) {
        u = _ref7[_m];
        if (pointlights[_splitRole("pointlight", u.role)] != null) {
          _typeCheckSet(u, pointlights, "pointlight");
        }
      }
    }
    if (obj.textures != null) {
      _ref8 = contract.textures;
      for (_n = 0, _len5 = _ref8.length; _n < _len5; _n++) {
        u = _ref8[_n];
        _ref9 = obj.textures;
        for (_o = 0, _len6 = _ref9.length; _o < _len6; _o++) {
          t = _ref9[_o];
          if (t[_splitRole("texture", u.role)] != null) {
            _typeCheckSet(u, t, "texture");
          }
        }
      }
    }
    _ref10 = contract.attributes;
    for (_p = 0, _len7 = _ref10.length; _p < _len7; _p++) {
      a = _ref10[_p];
      if (obj[a.role] != null) {
        _attribTypeCheckSet(a, obj);
      }
    }
    return obj;
  };

  _drawGL = function(obj, drawPrimitive) {
    var gl, shader;
    if (drawPrimitive == null) {
      drawPrimitive = gl.TRIANGLES;
    }
    gl = CoffeeGL.Context.gl;
    if (!obj.brewed) {
      return obj;
    }
    shader = CoffeeGL.Context.shader;
    if (obj.shader != null) {
      CoffeeGL.Context.shader = obj.shader;
      obj.shader.bind();
    }
    if (CoffeeGL.Context.shader == null) {
      CoffeeGLWarningOnce("No Shader bound but WebGL Draw called");
      return obj;
    }
    _matchWithShader(obj);
    if (obj.vertexIndexBuffer != null) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.vertexIndexBuffer);
      gl.drawElements(drawPrimitive, obj.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
    } else {
      gl.drawArrays(drawPrimitive, 0, obj.vertexPositionBuffer.numItems);
    }
    if (obj.shader != null) {
      obj.shader.unbind();
      CoffeeGL.Context.shader = shader;
    }
    return obj;
  };

  _washup = function() {};

  WebGLTriangle = {};

  WebGLTriangle.brewed = false;

  WebGLTriangle.brew = function() {
    var colours, gl, normals, size, uvs, v, vertices, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref3, _ref4, _ref5, _ref6;
    if ((this.geometry.v == null) || this.geometry.v.length <= 0) {
      return this;
    }
    gl = CoffeeGL.Context.gl;
    this.bufferType = gl.STATIC_DRAW;
    if (this.vertexPositionBuffer == null) {
      vertices = [];
      _ref3 = this.geometry.v;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        v = _ref3[_i];
        vertices = vertices.concat(v.p.flatten());
      }
      this.vertexPositionBuffer = createArrayBuffer(new Float32Array(vertices), this.bufferType, 3);
    }
    if (this.geometry.v[0].c != null) {
      if (!this.vertexColourBuffer) {
        colours = [];
        _ref4 = this.geometry.v;
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          v = _ref4[_j];
          colours = colours.concat(v.c.flatten());
        }
        size = 4;
        if (this.geometry.v[0].c instanceof Colour.RGB) {
          size = 3;
        }
        this.vertexColourBuffer = createArrayBuffer(new Float32Array(colours), this.bufferType, size);
      }
    }
    if (this.geometry.indices != null) {
      if (this.vertexIndexBuffer == null) {
        this.vertexIndexBuffer = createElementBuffer(new Uint16Array(this.geometry.indices), this.bufferType, 1);
      }
    }
    if (this.geometry.v[0].n != null) {
      if (this.vertexNormalBuffer == null) {
        normals = [];
        _ref5 = this.geometry.v;
        for (_k = 0, _len2 = _ref5.length; _k < _len2; _k++) {
          v = _ref5[_k];
          normals = normals.concat(v.n.flatten());
        }
        this.vertexNormalBuffer = createArrayBuffer(new Float32Array(normals), this.bufferType, 3);
      }
    }
    if (this.geometry.v[0].t != null) {
      if (this.vertexTextureBuffer == null) {
        uvs = [];
        _ref6 = this.geometry.v;
        for (_l = 0, _len3 = _ref6.length; _l < _len3; _l++) {
          v = _ref6[_l];
          uvs = uvs.concat(v.t.flatten());
        }
        this.vertexTextureBuffer = createArrayBuffer(new Float32Array(uvs), this.bufferType, 2);
      }
    }
    this.brewed = true;
    return this;
  };

  WebGLTriangle.drawGL = function() {
    var gl;
    gl = CoffeeGL.Context.gl;
    return _drawGL(this, gl.TRIANGLES);
  };

  WebGLTriangle.washup = function() {
    return this;
  };

  WebGLQuad = {};

  WebGLQuad.brewed = false;

  WebGLQuad.brew = WebGLTriangle.brew;

  WebGLQuad.drawGL = function() {
    var gl;
    gl = CoffeeGL.Context.gl;
    return _drawGL(this, gl.TRIANGLE_STRIP);
  };

  WebGLQuad.washup = WebGLTriangle.washup;

  WebGLTriangleMesh = {};

  WebGLTriangleMesh.brewed = false;

  WebGLTriangleMesh.brew = WebGLTriangle.brew;

  WebGLTriangleMesh.drawGL = WebGLTriangle.drawGL;

  makeDrawableGL = function(obj) {
    if (obj.geometry != null) {
      if (obj.geometry instanceof Triangle) {
        return util.extend(obj, WebGLTriangle);
      } else if (obj.geometry instanceof Quad) {
        return util.extend(obj, WebGLQuad);
      } else if (obj.geometry instanceof TriangleMesh) {
        return util.extend(obj, WebGLTriangleMesh);
      }
    }
  };

  module.exports = {
    makeDrawableGL: makeDrawableGL
  };

}).call(this);

},{"./math":4,"./colour":5,"./primitives":6,"./error":19,"./util":2}],16:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*                    __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/
*/


(function() {
  var Signal, makeMouseEmitter, mouseEmitter, util;

  util = require("./util");

  Signal = (function() {

    function Signal() {
      this.listeners = [];
    }

    Signal.prototype.add = function(func, context) {
      this.listeners.push({
        f: func,
        c: context
      });
      return this;
    };

    Signal.prototype.addOnce = function(func, context) {
      return this;
    };

    Signal.prototype.remove = function(obj) {
      this.del(obj);
      return this;
    };

    Signal.prototype.del = function(func) {
      var i, obj, _i, _len, _ref;
      _ref = this.listeners;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        if (obj.func === func) {
          i = this.listeners.indexOf(obj);
          this.listeners.splice(i, 1);
        }
      }
      return this;
    };

    Signal.prototype.dispatch = function() {
      var l, _i, _len, _ref;
      _ref = this.listeners;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        l.f.apply(l.c, arguments);
      }
      return this;
    };

    return Signal;

  })();

  mouseEmitter = {};

  mouseEmitter.mouseMove = new Signal();

  mouseEmitter.mouseDown = new Signal();

  mouseEmitter.mouseUp = new Signal();

  mouseEmitter.mouseClick = new Signal();

  mouseEmitter.mouseOut = new Signal();

  mouseEmitter.mouseOver = new Signal();

  mouseEmitter.mouseWheel = new Signal();

  mouseEmitter["_getMousePos"] = function(e) {
    var posx, posy;
    posx = 0;
    posy = 0;
    if (e.pageX || e.pageY) {
      posx = e.pageX;
      posy = e.pageY;
    } else if (e.clientX || e.clientY) {
      posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
      posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
    }
    e.mouseX = posx;
    e.mouseY = posy;
    return [posx, posy];
  };

  makeMouseEmitter = function(obj) {
    if (obj.canvas != null) {
      util.extend(obj, mouseEmitter);
      obj.canvas.onmousemove = function(event) {
        obj._getMousePos(event);
        return obj.mouseMove.dispatch(event);
      };
      obj.canvas.onmousedown = function(event) {
        obj._getMousePos(event);
        return obj.mouseDown.dispatch(event);
      };
      obj.canvas.onmouseup = function(event) {
        obj._getMousePos(event);
        return obj.mouseUp.dispatch(event);
      };
      obj.canvas.onmouseclick = function(event) {
        obj._getMousePos(event);
        return obj.mouseClick.dispatch(event);
      };
      obj.canvas.onmouseout = function(event) {
        obj._getMousePos(event);
        return obj.mouseOut.dispatch(event);
      };
      obj.canvas.onmouseover = function(event) {
        obj._getMousePos(event);
        return obj.mouseOver.dispatch(event);
      };
      return obj.canvas.onmousewheel = function(event) {
        obj._getMousePos(event);
        return obj.mouseWheel.dispatch(event);
      };
    }
  };

  module.exports = {
    Signal: Signal,
    makeMouseEmitter: makeMouseEmitter
  };

}).call(this);

},{"./util":2}],17:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*                    __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/

TODO - updating the pos and the matrix together :S tricksy
*/


(function() {
  var Colour, Matrix4, PointLight, Vec2, Vec3, Vec4, _ref;

  _ref = require('./math'), Matrix4 = _ref.Matrix4, Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Vec4 = _ref.Vec4;

  Colour = require('./colour').Colour;

  PointLight = (function() {

    function PointLight(pos, colour, specular, attenuation) {
      this.pos = pos;
      this.colour = colour;
      this.specular = specular;
      this.attenuation = attenuation;
      if (this.pos == null) {
        this.pos = new Vec3(1, 1, 1);
      }
      if (this.colour == null) {
        this.colour = Colour.RGB.WHITE();
      }
      if (this.specular == null) {
        this.specular = Colour.RGB.WHITE();
      }
      if (this.attenuation == null) {
        this.attenuation = 0.99;
      }
    }

    PointLight.prototype._addToNode = function(node) {
      node.pointLights.push(this);
      node.numPointLights = node.pointLights.length;
      return this;
    };

    PointLight.prototype._removeFromNode = function(node) {
      node.pointLights.splice(node.pointLights.indexOf(this));
      node.numPointLights = node.pointLights.length;
      return this;
    };

    return PointLight;

  })();

  module.exports = {
    PointLight: PointLight
  };

}).call(this);

},{"./math":4,"./colour":5}],18:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*                    __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/
*/


(function() {
  var Colour, Material;

  Colour = require("./colour").Colour;

  Material = (function() {

    function Material(ambient, diffuse, specular, shine, emissive) {
      this.ambient = ambient;
      this.diffuse = diffuse;
      this.specular = specular;
      this.shine = shine;
      this.emissive = emissive;
      if (this.ambient == null) {
        this.ambient = new Colour.RGB(0, 0, 0);
      }
      if (this.diffuse == null) {
        this.diffuse = new Colour.RGB(1.0, 1.0, 1.0);
      }
      if (this.specular == null) {
        this.specular = new Colour.RGB(1.0, 1.0, 1.0);
      }
      if (this.shine == null) {
        this.shine = 20.0;
      }
      if (this.emissive == null) {
        this.emissive = new Colour.RGB(0.0, 0.0, 0.0);
      }
    }

    Material.prototype._addToNode = function(node) {
      return node.material = this;
    };

    return Material;

  })();

  module.exports = {
    Material: Material
  };

}).call(this);

},{"./colour":5}],21:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*
                       __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/
*/


(function() {
  var ShaderLibrary;

  ShaderLibrary = (function() {

    function ShaderLibrary() {}

    ShaderLibrary.Basic = {
      vertex: "attribute vec3 aVertexPosition;uniform mat4 uModelMatrix; varying vec4 vColor;",
      fragment: ""
    };

    ShaderLibrary.BasicVertexColours = {
      vertex: "attribute vec4 aVertexColour;",
      fragment: "varying vec4 vColor;"
    };

    ShaderLibrary.BasicCamera = {
      vertex: "uniform mat4 uCameraMatrix;    uniform mat4 uCameraInverseMatrix;uniform mat4 uProjectionMatrix;",
      fragment: ""
    };

    ShaderLibrary.BasicVertexNormals = {
      vertex: "attribute vec3 aVertexNormal;varying vec3 vNormal;uniform mat3 uNormalMatrix;",
      fragment: "varying vec3 vNormal;"
    };

    ShaderLibrary.BasicTexture = {
      vertex: "attribute vec2 aVertexTexCoord;varying vec2 vTexCoord;",
      fragment: "varying vec2 vTexCoord;uniform sampler2D uSampler;"
    };

    return ShaderLibrary;

  })();

  module.exports = {
    ShaderLibrary: ShaderLibrary
  };

}).call(this);

},{}],20:[function(require,module,exports){
// Generated by CoffeeScript 1.6.1

/*                    __  .__              ________ 
   ______ ____   _____/  |_|__| ____   ____/   __   \
  /  ___// __ \_/ ___\   __\  |/  _ \ /    \____    /
  \___ \\  ___/\  \___|  | |  (  <_> )   |  \ /    / 
 /____  >\___  >\___  >__| |__|\____/|___|  //____/  .co.uk
      \/     \/     \/                    \/         
                                              CoffeeGL
                                              Benjamin Blundell - ben@section9.co.uk
                                              http://www.section9.co.uk

This software is released under Creative Commons Attribution Non-Commercial Share Alike
http://creativecommons.org/licenses/by-nc-sa/3.0/

TODO - updating the pos and the matrix together :S tricksy
*/


(function() {
  var Colour, Matrix4, PointLight, Vec2, Vec3, Vec4, _ref;

  _ref = require('./math'), Matrix4 = _ref.Matrix4, Vec2 = _ref.Vec2, Vec3 = _ref.Vec3, Vec4 = _ref.Vec4;

  Colour = require('./colour').Colour;

  PointLight = (function() {

    function PointLight(pos, colour, specular, attenuation) {
      this.pos = pos;
      this.colour = colour;
      this.specular = specular;
      this.attenuation = attenuation;
      if (this.pos == null) {
        this.pos = new Vec3(1, 1, 1);
      }
      if (this.colour == null) {
        this.colour = Colour.RGB.WHITE();
      }
      if (this.specular == null) {
        this.specular = Colour.RGB.WHITE();
      }
      if (this.attenuation == null) {
        this.attenuation = 0.99;
      }
    }

    PointLight.prototype._addToNode = function(node) {
      node.pointLights.push(this);
      node.numPointLights = node.pointLights.length;
      return this;
    };

    PointLight.prototype._removeFromNode = function(node) {
      node.pointLights.splice(node.pointLights.indexOf(this));
      node.numPointLights = node.pointLights.length;
      return this;
    };

    return PointLight;

  })();

  module.exports = {
    PointLight: PointLight
  };

}).call(this);

},{"./math":4,"./colour":5}]},{},[1])
;